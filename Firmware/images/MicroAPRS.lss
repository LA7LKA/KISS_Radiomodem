
images/MicroAPRS.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000018  00800100  000018f6  0000198a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000018f6  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000758  00800118  00800118  000019a2  2**0
                  ALLOC
  3 .stab         00004524  00000000  00000000  000019a4  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00002664  00000000  00000000  00005ec8  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000011  00000000  00000000  0000852c  2**0
                  CONTENTS, READONLY
  6 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00008540  2**2
                  CONTENTS, READONLY

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 b7 01 	jmp	0x36e	; 0x36e <__ctors_end>
       4:	0c 94 d4 01 	jmp	0x3a8	; 0x3a8 <__bad_interrupt>
       8:	0c 94 d4 01 	jmp	0x3a8	; 0x3a8 <__bad_interrupt>
       c:	0c 94 d4 01 	jmp	0x3a8	; 0x3a8 <__bad_interrupt>
      10:	0c 94 d4 01 	jmp	0x3a8	; 0x3a8 <__bad_interrupt>
      14:	0c 94 d4 01 	jmp	0x3a8	; 0x3a8 <__bad_interrupt>
      18:	0c 94 d4 01 	jmp	0x3a8	; 0x3a8 <__bad_interrupt>
      1c:	0c 94 d4 01 	jmp	0x3a8	; 0x3a8 <__bad_interrupt>
      20:	0c 94 d4 01 	jmp	0x3a8	; 0x3a8 <__bad_interrupt>
      24:	0c 94 d4 01 	jmp	0x3a8	; 0x3a8 <__bad_interrupt>
      28:	0c 94 d4 01 	jmp	0x3a8	; 0x3a8 <__bad_interrupt>
      2c:	0c 94 d4 01 	jmp	0x3a8	; 0x3a8 <__bad_interrupt>
      30:	0c 94 d4 01 	jmp	0x3a8	; 0x3a8 <__bad_interrupt>
      34:	0c 94 d4 01 	jmp	0x3a8	; 0x3a8 <__bad_interrupt>
      38:	0c 94 15 0a 	jmp	0x142a	; 0x142a <__vector_14>
      3c:	0c 94 d4 01 	jmp	0x3a8	; 0x3a8 <__bad_interrupt>
      40:	0c 94 d4 01 	jmp	0x3a8	; 0x3a8 <__bad_interrupt>
      44:	0c 94 d4 01 	jmp	0x3a8	; 0x3a8 <__bad_interrupt>
      48:	0c 94 d4 01 	jmp	0x3a8	; 0x3a8 <__bad_interrupt>
      4c:	0c 94 d4 01 	jmp	0x3a8	; 0x3a8 <__bad_interrupt>
      50:	0c 94 d4 01 	jmp	0x3a8	; 0x3a8 <__bad_interrupt>
      54:	0c 94 f0 06 	jmp	0xde0	; 0xde0 <__vector_21>
      58:	0c 94 d4 01 	jmp	0x3a8	; 0x3a8 <__bad_interrupt>
      5c:	0c 94 d4 01 	jmp	0x3a8	; 0x3a8 <__bad_interrupt>
      60:	0c 94 d4 01 	jmp	0x3a8	; 0x3a8 <__bad_interrupt>
      64:	0c 94 d4 01 	jmp	0x3a8	; 0x3a8 <__bad_interrupt>

00000068 <__trampolines_end>:
      68:	61 64       	ori	r22, 0x41	; 65
      6a:	61 70       	andi	r22, 0x01	; 1
      6c:	74 65       	ori	r23, 0x54	; 84
      6e:	64 20       	and	r6, r4
      70:	66 6f       	ori	r22, 0xF6	; 246
      72:	72 20       	and	r7, r2
      74:	41 74       	andi	r20, 0x41	; 65
      76:	6d 65       	ori	r22, 0x5D	; 93
      78:	6c 20       	and	r6, r12
      7a:	41 56       	subi	r20, 0x61	; 97
      7c:	52 20       	and	r5, r2
      7e:	61 6e       	ori	r22, 0xE1	; 225
      80:	64 20       	and	r6, r4
      82:	74 68       	ori	r23, 0x84	; 132
      84:	69 73       	andi	r22, 0x39	; 57
      86:	20 64       	ori	r18, 0x40	; 64
      88:	65 6d       	ori	r22, 0xD5	; 213
      8a:	6f 20       	and	r6, r15
      8c:	62 79       	andi	r22, 0x92	; 146
      8e:	20 4d       	sbci	r18, 0xD0	; 208
      90:	61 72       	andi	r22, 0x21	; 33
      92:	74 69       	ori	r23, 0x94	; 148
      94:	6e 20       	and	r6, r14
      96:	54 68       	ori	r21, 0x84	; 132
      98:	6f 6d       	ori	r22, 0xDF	; 223
      9a:	61 73       	andi	r22, 0x31	; 49
      9c:	0d 0a       	sbc	r0, r29
	...

0000009f <__c.2038>:
      9f:	67 65 6e 65 72 69 63 20 73 6f 66 74 75 61 72 74     generic softuart
      af:	20 64 72 69 76 65 72 20 63 6f 64 65 20 62 79 20      driver code by 
      bf:	43 6f 6c 69 6e 20 47 69 74 74 69 6e 73 0d 0a 00     Colin Gittins...

000000cf <__c.2036>:
      cf:	0d 0a 53 6f 66 74 75 61 72 74 20 44 65 6d 6f 2d     ..Softuart Demo-
      df:	41 70 70 6c 69 63 61 74 69 6f 6e 0d 0a 00           Application...

000000ed <sin_table>:
      ed:	80 81 83 84 86 87 89 8a 8c 8e 8f 91 92 94 95 97     ................
      fd:	98 9a 9b 9d 9e a0 a2 a3 a5 a6 a7 a9 aa ac ad af     ................
     10d:	b0 b2 b3 b5 b6 b7 b9 ba bc bd be c0 c1 c2 c4 c5     ................
     11d:	c6 c8 c9 ca cb cd ce cf d0 d2 d3 d4 d5 d6 d7 d9     ................
     12d:	da db dc dd de df e0 e1 e2 e3 e4 e5 e6 e7 e8 e9     ................
     13d:	ea ea eb ec ed ee ee ef f0 f1 f1 f2 f3 f3 f4 f5     ................
     14d:	f5 f6 f6 f7 f8 f8 f9 f9 fa fa fa fb fb fc fc fc     ................
     15d:	fd fd fd fd fe fe fe fe fe ff ff ff ff ff ff ff     ................

0000016d <crc_ccit_table>:
     16d:	00 00 89 11 12 23 9b 32 24 46 ad 57 36 65 bf 74     .....#.2$F.W6e.t
     17d:	48 8c c1 9d 5a af d3 be 6c ca e5 db 7e e9 f7 f8     H...Z...l...~...
     18d:	81 10 08 01 93 33 1a 22 a5 56 2c 47 b7 75 3e 64     .....3.".V,G.u>d
     19d:	c9 9c 40 8d db bf 52 ae ed da 64 cb ff f9 76 e8     ..@...R...d...v.
     1ad:	02 21 8b 30 10 02 99 13 26 67 af 76 34 44 bd 55     .!.0....&g.v4D.U
     1bd:	4a ad c3 bc 58 8e d1 9f 6e eb e7 fa 7c c8 f5 d9     J...X...n...|...
     1cd:	83 31 0a 20 91 12 18 03 a7 77 2e 66 b5 54 3c 45     .1. .....w.f.T<E
     1dd:	cb bd 42 ac d9 9e 50 8f ef fb 66 ea fd d8 74 c9     ..B...P...f...t.
     1ed:	04 42 8d 53 16 61 9f 70 20 04 a9 15 32 27 bb 36     .B.S.a.p ...2'.6
     1fd:	4c ce c5 df 5e ed d7 fc 68 88 e1 99 7a ab f3 ba     L...^...h...z...
     20d:	85 52 0c 43 97 71 1e 60 a1 14 28 05 b3 37 3a 26     .R.C.q.`..(..7:&
     21d:	cd de 44 cf df fd 56 ec e9 98 60 89 fb bb 72 aa     ..D...V...`...r.
     22d:	06 63 8f 72 14 40 9d 51 22 25 ab 34 30 06 b9 17     .c.r.@.Q"%.40...
     23d:	4e ef c7 fe 5c cc d5 dd 6a a9 e3 b8 78 8a f1 9b     N...\...j...x...
     24d:	87 73 0e 62 95 50 1c 41 a3 35 2a 24 b1 16 38 07     .s.b.P.A.5*$..8.
     25d:	cf ff 46 ee dd dc 54 cd eb b9 62 a8 f9 9a 70 8b     ..F...T...b...p.
     26d:	08 84 81 95 1a a7 93 b6 2c c2 a5 d3 3e e1 b7 f0     ........,...>...
     27d:	40 08 c9 19 52 2b db 3a 64 4e ed 5f 76 6d ff 7c     @...R+.:dN._vm.|
     28d:	89 94 00 85 9b b7 12 a6 ad d2 24 c3 bf f1 36 e0     ..........$...6.
     29d:	c1 18 48 09 d3 3b 5a 2a e5 5e 6c 4f f7 7d 7e 6c     ..H..;Z*.^lO.}~l
     2ad:	0a a5 83 b4 18 86 91 97 2e e3 a7 f2 3c c0 b5 d1     ............<...
     2bd:	42 29 cb 38 50 0a d9 1b 66 6f ef 7e 74 4c fd 5d     B).8P...fo.~tL.]
     2cd:	8b b5 02 a4 99 96 10 87 af f3 26 e2 bd d0 34 c1     ..........&...4.
     2dd:	c3 39 4a 28 d1 1a 58 0b e7 7f 6e 6e f5 5c 7c 4d     .9J(..X...nn.\|M
     2ed:	0c c6 85 d7 1e e5 97 f4 28 80 a1 91 3a a3 b3 b2     ........(...:...
     2fd:	44 4a cd 5b 56 69 df 78 60 0c e9 1d 72 2f fb 3e     DJ.[Vi.x`...r/.>
     30d:	8d d6 04 c7 9f f5 16 e4 a9 90 20 81 bb b3 32 a2     .......... ...2.
     31d:	c5 5a 4c 4b d7 79 5e 68 e1 1c 68 0d f3 3f 7a 2e     .ZLK.y^h..h..?z.
     32d:	0e e7 87 f6 1c c4 95 d5 2a a1 a3 b0 38 82 b1 93     ........*...8...
     33d:	46 6b cf 7a 54 48 dd 59 62 2d eb 3c 70 0e f9 1f     Fk.zTH.Yb-.<p...
     34d:	8f f7 06 e6 9d d4 14 c5 ab b1 22 a0 b9 92 30 83     .........."...0.
     35d:	c7 7b 4e 6a d5 58 5c 49 e3 3d 6a 2c f1 1e 78 0f     .{Nj.X\I.=j,..x.
	...

0000036e <__ctors_end>:
     36e:	11 24       	eor	r1, r1
     370:	1f be       	out	0x3f, r1	; 63
     372:	cf ef       	ldi	r28, 0xFF	; 255
     374:	d8 e0       	ldi	r29, 0x08	; 8
     376:	de bf       	out	0x3e, r29	; 62
     378:	cd bf       	out	0x3d, r28	; 61

0000037a <__do_copy_data>:
     37a:	11 e0       	ldi	r17, 0x01	; 1
     37c:	a0 e0       	ldi	r26, 0x00	; 0
     37e:	b1 e0       	ldi	r27, 0x01	; 1
     380:	e6 ef       	ldi	r30, 0xF6	; 246
     382:	f8 e1       	ldi	r31, 0x18	; 24
     384:	02 c0       	rjmp	.+4      	; 0x38a <__do_copy_data+0x10>
     386:	05 90       	lpm	r0, Z+
     388:	0d 92       	st	X+, r0
     38a:	a8 31       	cpi	r26, 0x18	; 24
     38c:	b1 07       	cpc	r27, r17
     38e:	d9 f7       	brne	.-10     	; 0x386 <__do_copy_data+0xc>

00000390 <__do_clear_bss>:
     390:	28 e0       	ldi	r18, 0x08	; 8
     392:	a8 e1       	ldi	r26, 0x18	; 24
     394:	b1 e0       	ldi	r27, 0x01	; 1
     396:	01 c0       	rjmp	.+2      	; 0x39a <.do_clear_bss_start>

00000398 <.do_clear_bss_loop>:
     398:	1d 92       	st	X+, r1

0000039a <.do_clear_bss_start>:
     39a:	a0 37       	cpi	r26, 0x70	; 112
     39c:	b2 07       	cpc	r27, r18
     39e:	e1 f7       	brne	.-8      	; 0x398 <.do_clear_bss_loop>
     3a0:	0e 94 1d 0b 	call	0x163a	; 0x163a <main>
     3a4:	0c 94 79 0c 	jmp	0x18f2	; 0x18f2 <_exit>

000003a8 <__bad_interrupt>:
     3a8:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000003ac <ax25_callback>:
Afsk modem;
AX25Ctx AX25;

#if SERIAL_PROTOCOL == PROTOCOL_KISS
    static void ax25_callback(struct AX25Ctx *ctx) {
        kiss_messageCallback(ctx);
     3ac:	0c 94 a1 08 	jmp	0x1142	; 0x1142 <kiss_messageCallback>

000003b0 <init>:
        ss_messageCallback(msg);
    }
#endif

void init(void) {
    sei();
     3b0:	78 94       	sei

    AFSK_init(&modem);
     3b2:	80 e6       	ldi	r24, 0x60	; 96
     3b4:	94 e0       	ldi	r25, 0x04	; 4
     3b6:	0e 94 4b 03 	call	0x696	; 0x696 <AFSK_init>
    ax25_init(&AX25, &modem.fd, ax25_callback);
     3ba:	46 ed       	ldi	r20, 0xD6	; 214
     3bc:	51 e0       	ldi	r21, 0x01	; 1
     3be:	60 e6       	ldi	r22, 0x60	; 96
     3c0:	74 e0       	ldi	r23, 0x04	; 4
     3c2:	8c e3       	ldi	r24, 0x3C	; 60
     3c4:	95 e0       	ldi	r25, 0x05	; 5
     3c6:	0e 94 88 07 	call	0xf10	; 0xf10 <ax25_init>

    serial_init(&serial);    
     3ca:	8e e2       	ldi	r24, 0x2E	; 46
     3cc:	95 e0       	ldi	r25, 0x05	; 5
     3ce:	0e 94 06 02 	call	0x40c	; 0x40c <serial_init>
    stdout = &serial.uart0;
     3d2:	ea e6       	ldi	r30, 0x6A	; 106
     3d4:	f8 e0       	ldi	r31, 0x08	; 8
     3d6:	8e e2       	ldi	r24, 0x2E	; 46
     3d8:	95 e0       	ldi	r25, 0x05	; 5
     3da:	93 83       	std	Z+3, r25	; 0x03
     3dc:	82 83       	std	Z+2, r24	; 0x02
    stdin  = &serial.uart0;
     3de:	91 83       	std	Z+1, r25	; 0x01
     3e0:	80 83       	st	Z, r24

    #if SERIAL_PROTOCOL == PROTOCOL_KISS
        kiss_init(&AX25, &modem, &serial);
     3e2:	ac 01       	movw	r20, r24
     3e4:	60 e6       	ldi	r22, 0x60	; 96
     3e6:	74 e0       	ldi	r23, 0x04	; 4
     3e8:	8c e3       	ldi	r24, 0x3C	; 60
     3ea:	95 e0       	ldi	r25, 0x05	; 5
     3ec:	0c 94 94 08 	jmp	0x1128	; 0x1128 <kiss_init>

000003f0 <uart0_putchar>:
    return false;
}


void uart0_putchar(char c) {
    loop_until_bit_is_set(UCSR0A, UDRE0);
     3f0:	90 91 c0 00 	lds	r25, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
     3f4:	95 ff       	sbrs	r25, 5
     3f6:	fc cf       	rjmp	.-8      	; 0x3f0 <uart0_putchar>
    UDR0 = c;
     3f8:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
     3fc:	08 95       	ret

000003fe <uart0_getchar>:
}

char uart0_getchar(void) {
    loop_until_bit_is_set(UCSR0A, RXC0);
     3fe:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
     402:	87 ff       	sbrs	r24, 7
     404:	fc cf       	rjmp	.-8      	; 0x3fe <uart0_getchar>
    return UDR0;
     406:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
}
     40a:	08 95       	ret

0000040c <serial_init>:
#include "Serial.h"
#include <util/setbaud.h>
#include <stdio.h>
#include <string.h>

void serial_init(Serial *serial) {
     40c:	cf 93       	push	r28
     40e:	df 93       	push	r29
     410:	cd b7       	in	r28, 0x3d	; 61
     412:	de b7       	in	r29, 0x3e	; 62
     414:	2e 97       	sbiw	r28, 0x0e	; 14
     416:	0f b6       	in	r0, 0x3f	; 63
     418:	f8 94       	cli
     41a:	de bf       	out	0x3e, r29	; 62
     41c:	0f be       	out	0x3f, r0	; 63
     41e:	cd bf       	out	0x3d, r28	; 61
     420:	dc 01       	movw	r26, r24
    memset(serial, 0, sizeof(*serial));
     422:	8e e0       	ldi	r24, 0x0E	; 14
     424:	fd 01       	movw	r30, r26
     426:	98 2f       	mov	r25, r24
     428:	11 92       	st	Z+, r1
     42a:	9a 95       	dec	r25
     42c:	e9 f7       	brne	.-6      	; 0x428 <serial_init+0x1c>
    UBRR0H = UBRRH_VALUE;
     42e:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
    UBRR0L = UBRRL_VALUE;
     432:	93 e3       	ldi	r25, 0x33	; 51
     434:	90 93 c4 00 	sts	0x00C4, r25	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>

    #if USE_2X
        UCSR0A |= _BV(U2X0);
    #else
        UCSR0A &= ~(_BV(U2X0));
     438:	e0 ec       	ldi	r30, 0xC0	; 192
     43a:	f0 e0       	ldi	r31, 0x00	; 0
     43c:	90 81       	ld	r25, Z
     43e:	9d 7f       	andi	r25, 0xFD	; 253
     440:	90 83       	st	Z, r25
    #endif

    // Set to 8-bit data, enable RX and TX
    UCSR0C = _BV(UCSZ01) | _BV(UCSZ00);
     442:	96 e0       	ldi	r25, 0x06	; 6
     444:	90 93 c2 00 	sts	0x00C2, r25	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
    UCSR0B = _BV(RXEN0) | _BV(TXEN0);
     448:	98 e1       	ldi	r25, 0x18	; 24
     44a:	90 93 c1 00 	sts	0x00C1, r25	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>

    FILE uart0_fd = FDEV_SETUP_STREAM(uart0_putchar, uart0_getchar, _FDEV_SETUP_RW);
     44e:	9e 01       	movw	r18, r28
     450:	2f 5f       	subi	r18, 0xFF	; 255
     452:	3f 4f       	sbci	r19, 0xFF	; 255
     454:	f9 01       	movw	r30, r18
     456:	11 92       	st	Z+, r1
     458:	8a 95       	dec	r24
     45a:	e9 f7       	brne	.-6      	; 0x456 <serial_init+0x4a>

    serial->uart0 = uart0_fd;
     45c:	83 e0       	ldi	r24, 0x03	; 3
     45e:	8c 83       	std	Y+4, r24	; 0x04
     460:	88 ef       	ldi	r24, 0xF8	; 248
     462:	91 e0       	ldi	r25, 0x01	; 1
     464:	9a 87       	std	Y+10, r25	; 0x0a
     466:	89 87       	std	Y+9, r24	; 0x09
     468:	8f ef       	ldi	r24, 0xFF	; 255
     46a:	91 e0       	ldi	r25, 0x01	; 1
     46c:	9c 87       	std	Y+12, r25	; 0x0c
     46e:	8b 87       	std	Y+11, r24	; 0x0b
     470:	9e e0       	ldi	r25, 0x0E	; 14
     472:	f9 01       	movw	r30, r18
     474:	01 90       	ld	r0, Z+
     476:	0d 92       	st	X+, r0
     478:	9a 95       	dec	r25
     47a:	e1 f7       	brne	.-8      	; 0x474 <serial_init+0x68>
}
     47c:	2e 96       	adiw	r28, 0x0e	; 14
     47e:	0f b6       	in	r0, 0x3f	; 63
     480:	f8 94       	cli
     482:	de bf       	out	0x3e, r29	; 62
     484:	0f be       	out	0x3f, r0	; 63
     486:	cd bf       	out	0x3d, r28	; 61
     488:	df 91       	pop	r29
     48a:	cf 91       	pop	r28
     48c:	08 95       	ret

0000048e <serial_available>:

bool serial_available(uint8_t index) {
    if (index == 0) {
     48e:	81 11       	cpse	r24, r1
     490:	06 c0       	rjmp	.+12     	; 0x49e <serial_available+0x10>
        if (UCSR0A & _BV(RXC0)) return true;
     492:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
     496:	88 1f       	adc	r24, r24
     498:	88 27       	eor	r24, r24
     49a:	88 1f       	adc	r24, r24
     49c:	08 95       	ret
    }
    return false;
     49e:	80 e0       	ldi	r24, 0x00	; 0
}
     4a0:	08 95       	ret

000004a2 <uart0_getchar_nowait>:
    loop_until_bit_is_set(UCSR0A, RXC0);
    return UDR0;
}

char uart0_getchar_nowait(void) {
    if (!(UCSR0A & _BV(RXC0))) return EOF;
     4a2:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
     4a6:	87 ff       	sbrs	r24, 7
     4a8:	03 c0       	rjmp	.+6      	; 0x4b0 <uart0_getchar_nowait+0xe>
    return UDR0;
     4aa:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
     4ae:	08 95       	ret
    loop_until_bit_is_set(UCSR0A, RXC0);
    return UDR0;
}

char uart0_getchar_nowait(void) {
    if (!(UCSR0A & _BV(RXC0))) return EOF;
     4b0:	8f ef       	ldi	r24, 0xFF	; 255
    return UDR0;
     4b2:	08 95       	ret

000004b4 <afsk_putchar>:
    ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
      afsk->tailLength = DIV_ROUND(custom_tail * BITRATE, 8000);
    }
}

void afsk_putchar(char c) {
     4b4:	0f 93       	push	r16
     4b6:	1f 93       	push	r17
     4b8:	cf 93       	push	r28
     4ba:	df 93       	push	r29
     4bc:	18 2f       	mov	r17, r24
    AFSK_txStart(AFSK_modem);
     4be:	c0 91 60 08 	lds	r28, 0x0860	; 0x800860 <AFSK_modem>
     4c2:	d0 91 61 08 	lds	r29, 0x0861	; 0x800861 <AFSK_modem+0x1>
    FILE afsk_fd = FDEV_SETUP_STREAM(afsk_putchar, afsk_getchar, _FDEV_SETUP_RW);
    afsk->fd = afsk_fd;
}

static void AFSK_txStart(Afsk *afsk) {
    if (!afsk->sending) {
     4c6:	fe 01       	movw	r30, r28
     4c8:	e9 59       	subi	r30, 0x99	; 153
     4ca:	ff 4f       	sbci	r31, 0xFF	; 255
     4cc:	80 81       	ld	r24, Z
     4ce:	81 11       	cpse	r24, r1
     4d0:	24 c0       	rjmp	.+72     	; 0x51a <afsk_putchar+0x66>
        afsk->phaseInc = MARK_INC;
     4d2:	80 e4       	ldi	r24, 0x40	; 64
     4d4:	90 e0       	ldi	r25, 0x00	; 0
     4d6:	9e 8f       	std	Y+30, r25	; 0x1e
     4d8:	8d 8f       	std	Y+29, r24	; 0x1d
        afsk->phaseAcc = 0;
     4da:	1c 8e       	std	Y+28, r1	; 0x1c
     4dc:	1b 8e       	std	Y+27, r1	; 0x1b
        afsk->bitstuffCount = 0;
     4de:	1a 8e       	std	Y+26, r1	; 0x1a
        afsk->sending = true;
     4e0:	01 e0       	ldi	r16, 0x01	; 1
     4e2:	00 83       	st	Z, r16
        LED_TX_ON();
     4e4:	29 9a       	sbi	0x05, 1	; 5
        afsk->preambleLength = DIV_ROUND(custom_preamble * BITRATE, 8000);
     4e6:	20 91 09 01 	lds	r18, 0x0109	; 0x800109 <custom_preamble>
     4ea:	30 91 0a 01 	lds	r19, 0x010A	; 0x80010a <custom_preamble+0x1>
     4ee:	40 91 0b 01 	lds	r20, 0x010B	; 0x80010b <custom_preamble+0x2>
     4f2:	50 91 0c 01 	lds	r21, 0x010C	; 0x80010c <custom_preamble+0x3>
     4f6:	a0 eb       	ldi	r26, 0xB0	; 176
     4f8:	b4 e0       	ldi	r27, 0x04	; 4
     4fa:	0e 94 75 0b 	call	0x16ea	; 0x16ea <__muluhisi3>
     4fe:	60 56       	subi	r22, 0x60	; 96
     500:	70 4f       	sbci	r23, 0xF0	; 240
     502:	8f 4f       	sbci	r24, 0xFF	; 255
     504:	9f 4f       	sbci	r25, 0xFF	; 255
     506:	20 e4       	ldi	r18, 0x40	; 64
     508:	3f e1       	ldi	r19, 0x1F	; 31
     50a:	40 e0       	ldi	r20, 0x00	; 0
     50c:	50 e0       	ldi	r21, 0x00	; 0
     50e:	0e 94 44 0b 	call	0x1688	; 0x1688 <__udivmodsi4>
     512:	3b 8b       	std	Y+19, r19	; 0x13
     514:	2a 8b       	std	Y+18, r18	; 0x12
        AFSK_DAC_IRQ_START();
     516:	00 93 19 01 	sts	0x0119, r16	; 0x800119 <hw_afsk_dac_isr>
    }
    ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
     51a:	0f b7       	in	r16, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
     51c:	f8 94       	cli
      afsk->tailLength = DIV_ROUND(custom_tail * BITRATE, 8000);
     51e:	20 91 05 01 	lds	r18, 0x0105	; 0x800105 <custom_tail>
     522:	30 91 06 01 	lds	r19, 0x0106	; 0x800106 <custom_tail+0x1>
     526:	40 91 07 01 	lds	r20, 0x0107	; 0x800107 <custom_tail+0x2>
     52a:	50 91 08 01 	lds	r21, 0x0108	; 0x800108 <custom_tail+0x3>
     52e:	a0 eb       	ldi	r26, 0xB0	; 176
     530:	b4 e0       	ldi	r27, 0x04	; 4
     532:	0e 94 75 0b 	call	0x16ea	; 0x16ea <__muluhisi3>
     536:	60 56       	subi	r22, 0x60	; 96
     538:	70 4f       	sbci	r23, 0xF0	; 240
     53a:	8f 4f       	sbci	r24, 0xFF	; 255
     53c:	9f 4f       	sbci	r25, 0xFF	; 255
     53e:	20 e4       	ldi	r18, 0x40	; 64
     540:	3f e1       	ldi	r19, 0x1F	; 31
     542:	40 e0       	ldi	r20, 0x00	; 0
     544:	50 e0       	ldi	r21, 0x00	; 0
     546:	0e 94 44 0b 	call	0x1688	; 0x1688 <__udivmodsi4>
     54a:	3d 8b       	std	Y+21, r19	; 0x15
     54c:	2c 8b       	std	Y+20, r18	; 0x14
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
     54e:	0f bf       	out	0x3f, r16	; 63
    }
}

void afsk_putchar(char c) {
    AFSK_txStart(AFSK_modem);
    while(fifo_isfull_locked(&AFSK_modem->txFifo)) { /* Wait */ }
     550:	e0 91 60 08 	lds	r30, 0x0860	; 0x800860 <AFSK_modem>
     554:	f0 91 61 08 	lds	r31, 0x0861	; 0x800861 <AFSK_modem+0x1>
  return result;
}

static inline bool fifo_isfull_locked(const FIFOBuffer *f) {
  bool result;
  ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
     558:	4f b7       	in	r20, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
     55a:	f8 94       	cli
inline bool fifo_isempty(const FIFOBuffer *f) {
  return f->head == f->tail;
}

inline bool fifo_isfull(const FIFOBuffer *f) {
  return ((f->head == f->begin) && (f->tail == f->end)) || (f->tail == f->head - 1);
     55c:	23 a1       	ldd	r18, Z+35	; 0x23
     55e:	34 a1       	ldd	r19, Z+36	; 0x24
     560:	87 8d       	ldd	r24, Z+31	; 0x1f
     562:	90 a1       	ldd	r25, Z+32	; 0x20
     564:	28 17       	cp	r18, r24
     566:	39 07       	cpc	r19, r25
     568:	39 f4       	brne	.+14     	; 0x578 <afsk_putchar+0xc4>
     56a:	25 a1       	ldd	r18, Z+37	; 0x25
     56c:	36 a1       	ldd	r19, Z+38	; 0x26
     56e:	81 a1       	ldd	r24, Z+33	; 0x21
     570:	92 a1       	ldd	r25, Z+34	; 0x22
     572:	28 17       	cp	r18, r24
     574:	39 07       	cpc	r19, r25
     576:	79 f0       	breq	.+30     	; 0x596 <afsk_putchar+0xe2>
     578:	65 a1       	ldd	r22, Z+37	; 0x25
     57a:	76 a1       	ldd	r23, Z+38	; 0x26
     57c:	23 a1       	ldd	r18, Z+35	; 0x23
     57e:	34 a1       	ldd	r19, Z+36	; 0x24
     580:	21 50       	subi	r18, 0x01	; 1
     582:	31 09       	sbc	r19, r1
     584:	91 e0       	ldi	r25, 0x01	; 1
     586:	80 e0       	ldi	r24, 0x00	; 0
     588:	62 17       	cp	r22, r18
     58a:	73 07       	cpc	r23, r19
     58c:	09 f0       	breq	.+2      	; 0x590 <afsk_putchar+0xdc>
     58e:	90 e0       	ldi	r25, 0x00	; 0
     590:	29 2f       	mov	r18, r25
     592:	38 2f       	mov	r19, r24
     594:	02 c0       	rjmp	.+4      	; 0x59a <afsk_putchar+0xe6>
     596:	21 e0       	ldi	r18, 0x01	; 1
     598:	30 e0       	ldi	r19, 0x00	; 0
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
     59a:	4f bf       	out	0x3f, r20	; 63
     59c:	23 2b       	or	r18, r19
     59e:	c1 f6       	brne	.-80     	; 0x550 <afsk_putchar+0x9c>
    fifo_push_locked(&AFSK_modem->txFifo, c);
     5a0:	e0 91 60 08 	lds	r30, 0x0860	; 0x800860 <AFSK_modem>
     5a4:	f0 91 61 08 	lds	r31, 0x0861	; 0x800861 <AFSK_modem+0x1>
  }
  return result;
}

static inline void fifo_push_locked(FIFOBuffer *f, unsigned char c) {
  ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
     5a8:	2f b7       	in	r18, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
     5aa:	f8 94       	cli
inline bool fifo_isfull(const FIFOBuffer *f) {
  return ((f->head == f->begin) && (f->tail == f->end)) || (f->tail == f->head - 1);
}

inline void fifo_push(FIFOBuffer *f, unsigned char c) {
  *(f->tail) = c;
     5ac:	a5 a1       	ldd	r26, Z+37	; 0x25
     5ae:	b6 a1       	ldd	r27, Z+38	; 0x26
     5b0:	1c 93       	st	X, r17
  
  if (f->tail == f->end) {
     5b2:	45 a1       	ldd	r20, Z+37	; 0x25
     5b4:	56 a1       	ldd	r21, Z+38	; 0x26
     5b6:	81 a1       	ldd	r24, Z+33	; 0x21
     5b8:	92 a1       	ldd	r25, Z+34	; 0x22
     5ba:	48 17       	cp	r20, r24
     5bc:	59 07       	cpc	r21, r25
     5be:	19 f4       	brne	.+6      	; 0x5c6 <afsk_putchar+0x112>
    f->tail = f->begin;
     5c0:	87 8d       	ldd	r24, Z+31	; 0x1f
     5c2:	90 a1       	ldd	r25, Z+32	; 0x20
     5c4:	03 c0       	rjmp	.+6      	; 0x5cc <afsk_putchar+0x118>
  } else {
    f->tail++;
     5c6:	85 a1       	ldd	r24, Z+37	; 0x25
     5c8:	96 a1       	ldd	r25, Z+38	; 0x26
     5ca:	01 96       	adiw	r24, 0x01	; 1
     5cc:	96 a3       	std	Z+38, r25	; 0x26
     5ce:	85 a3       	std	Z+37, r24	; 0x25
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
     5d0:	2f bf       	out	0x3f, r18	; 63
}
     5d2:	df 91       	pop	r29
     5d4:	cf 91       	pop	r28
     5d6:	1f 91       	pop	r17
     5d8:	0f 91       	pop	r16
     5da:	08 95       	ret

000005dc <afsk_getchar>:

int afsk_getchar(void) {
    if (fifo_isempty_locked(&AFSK_modem->rxFifo)) {
     5dc:	e0 91 60 08 	lds	r30, 0x0860	; 0x800860 <AFSK_modem>
     5e0:	f0 91 61 08 	lds	r31, 0x0861	; 0x800861 <AFSK_modem+0x1>
  f->head = f->tail;
}

static inline bool fifo_isempty_locked(const FIFOBuffer *f) {
  bool result;
  ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
     5e4:	4f b7       	in	r20, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
     5e6:	f8 94       	cli
  unsigned char * volatile head;
  unsigned char * volatile tail;
} FIFOBuffer;

inline bool fifo_isempty(const FIFOBuffer *f) {
  return f->head == f->tail;
     5e8:	eb 58       	subi	r30, 0x8B	; 139
     5ea:	ff 4f       	sbci	r31, 0xFF	; 255
     5ec:	24 81       	ldd	r18, Z+4	; 0x04
     5ee:	35 81       	ldd	r19, Z+5	; 0x05
     5f0:	86 81       	ldd	r24, Z+6	; 0x06
     5f2:	97 81       	ldd	r25, Z+7	; 0x07
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
     5f4:	4f bf       	out	0x3f, r20	; 63
     5f6:	28 17       	cp	r18, r24
     5f8:	39 07       	cpc	r19, r25
     5fa:	e9 f0       	breq	.+58     	; 0x636 <afsk_getchar+0x5a>
        return EOF;
    } else {
        return fifo_pop_locked(&AFSK_modem->rxFifo);
     5fc:	e0 91 60 08 	lds	r30, 0x0860	; 0x800860 <AFSK_modem>
     600:	f0 91 61 08 	lds	r31, 0x0861	; 0x800861 <AFSK_modem+0x1>
  }
}

static inline unsigned char fifo_pop_locked(FIFOBuffer *f) {
  unsigned char c;
  ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
     604:	9f b7       	in	r25, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
     606:	f8 94       	cli
    f->tail++;
  }
}

inline unsigned char fifo_pop(FIFOBuffer *f) {
  if(f->head == f->end) {
     608:	eb 58       	subi	r30, 0x8B	; 139
     60a:	ff 4f       	sbci	r31, 0xFF	; 255
     60c:	a4 81       	ldd	r26, Z+4	; 0x04
     60e:	b5 81       	ldd	r27, Z+5	; 0x05
     610:	22 81       	ldd	r18, Z+2	; 0x02
     612:	33 81       	ldd	r19, Z+3	; 0x03
     614:	a2 17       	cp	r26, r18
     616:	b3 07       	cpc	r27, r19
     618:	19 f4       	brne	.+6      	; 0x620 <afsk_getchar+0x44>
    f->head = f->begin;
     61a:	20 81       	ld	r18, Z
     61c:	31 81       	ldd	r19, Z+1	; 0x01
     61e:	05 c0       	rjmp	.+10     	; 0x62a <afsk_getchar+0x4e>
    return *(f->end);
  } else {
    return *(f->head++);
     620:	a4 81       	ldd	r26, Z+4	; 0x04
     622:	b5 81       	ldd	r27, Z+5	; 0x05
     624:	9d 01       	movw	r18, r26
     626:	2f 5f       	subi	r18, 0xFF	; 255
     628:	3f 4f       	sbci	r19, 0xFF	; 255
     62a:	35 83       	std	Z+5, r19	; 0x05
     62c:	24 83       	std	Z+4, r18	; 0x04
     62e:	8c 91       	ld	r24, X
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
     630:	9f bf       	out	0x3f, r25	; 63
     632:	90 e0       	ldi	r25, 0x00	; 0
     634:	08 95       	ret
    fifo_push_locked(&AFSK_modem->txFifo, c);
}

int afsk_getchar(void) {
    if (fifo_isempty_locked(&AFSK_modem->rxFifo)) {
        return EOF;
     636:	8f ef       	ldi	r24, 0xFF	; 255
     638:	9f ef       	ldi	r25, 0xFF	; 255
    } else {
        return fifo_pop_locked(&AFSK_modem->rxFifo);
    }
}
     63a:	08 95       	ret

0000063c <AFSK_hw_refDetect>:
void AFSK_hw_refDetect(void) {
    // This is manual for now
    #if ADC_REFERENCE == REF_5V
        hw_5v_ref = true;
    #else
        hw_5v_ref = false;
     63c:	10 92 18 01 	sts	0x0118, r1	; 0x800118 <__data_end>
     640:	08 95       	ret

00000642 <AFSK_hw_init>:
     642:	10 92 18 01 	sts	0x0118, r1	; 0x800118 <__data_end>
void AFSK_hw_init(void) {
    // Set up ADC

    AFSK_hw_refDetect();

    TCCR1A = 0;                                    
     646:	10 92 80 00 	sts	0x0080, r1	; 0x800080 <__TEXT_REGION_LENGTH__+0x7e0080>
    TCCR1B = _BV(CS10) | _BV(WGM13) | _BV(WGM12);
     64a:	89 e1       	ldi	r24, 0x19	; 25
     64c:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
    ICR1 = (((CPU_FREQ+FREQUENCY_CORRECTION)) / 9600) - 1;
     650:	80 e4       	ldi	r24, 0x40	; 64
     652:	93 e0       	ldi	r25, 0x03	; 3
     654:	90 93 87 00 	sts	0x0087, r25	; 0x800087 <__TEXT_REGION_LENGTH__+0x7e0087>
     658:	80 93 86 00 	sts	0x0086, r24	; 0x800086 <__TEXT_REGION_LENGTH__+0x7e0086>

    if (hw_5v_ref) {
     65c:	80 91 18 01 	lds	r24, 0x0118	; 0x800118 <__data_end>
     660:	88 23       	and	r24, r24
     662:	21 f0       	breq	.+8      	; 0x66c <AFSK_hw_init+0x2a>
        ADMUX = _BV(REFS0) | 0;
     664:	80 e4       	ldi	r24, 0x40	; 64
     666:	80 93 7c 00 	sts	0x007C, r24	; 0x80007c <__TEXT_REGION_LENGTH__+0x7e007c>
     66a:	02 c0       	rjmp	.+4      	; 0x670 <AFSK_hw_init+0x2e>
    } else {
        ADMUX = 0;
     66c:	10 92 7c 00 	sts	0x007C, r1	; 0x80007c <__TEXT_REGION_LENGTH__+0x7e007c>
    }

    ADC_DDR  &= ~_BV(0);
     670:	38 98       	cbi	0x07, 0	; 7
    ADC_PORT &= ~_BV(0);
     672:	40 98       	cbi	0x08, 0	; 8
    DIDR0 |= _BV(0);
     674:	80 91 7e 00 	lds	r24, 0x007E	; 0x80007e <__TEXT_REGION_LENGTH__+0x7e007e>
     678:	81 60       	ori	r24, 0x01	; 1
     67a:	80 93 7e 00 	sts	0x007E, r24	; 0x80007e <__TEXT_REGION_LENGTH__+0x7e007e>
    ADCSRB =    _BV(ADTS2) |
     67e:	87 e0       	ldi	r24, 0x07	; 7
     680:	80 93 7b 00 	sts	0x007B, r24	; 0x80007b <__TEXT_REGION_LENGTH__+0x7e007b>
                _BV(ADTS1) |
                _BV(ADTS0);  
    ADCSRA =    _BV(ADEN) |
     684:	8c ee       	ldi	r24, 0xEC	; 236
     686:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
                _BV(ADSC) |
                _BV(ADATE)|
                _BV(ADIE) |
                _BV(ADPS2);

    AFSK_DAC_INIT();
     68a:	8a b1       	in	r24, 0x0a	; 10
     68c:	88 6f       	ori	r24, 0xF8	; 248
     68e:	8a b9       	out	0x0a, r24	; 10
    LED_TX_INIT();
     690:	21 9a       	sbi	0x04, 1	; 4
    LED_RX_INIT();
     692:	22 9a       	sbi	0x04, 2	; 4
     694:	08 95       	ret

00000696 <AFSK_init>:
}

void AFSK_init(Afsk *afsk) {
     696:	0f 93       	push	r16
     698:	1f 93       	push	r17
     69a:	cf 93       	push	r28
     69c:	df 93       	push	r29
     69e:	cd b7       	in	r28, 0x3d	; 61
     6a0:	de b7       	in	r29, 0x3e	; 62
     6a2:	2e 97       	sbiw	r28, 0x0e	; 14
     6a4:	0f b6       	in	r0, 0x3f	; 63
     6a6:	f8 94       	cli
     6a8:	de bf       	out	0x3e, r29	; 62
     6aa:	0f be       	out	0x3f, r0	; 63
     6ac:	cd bf       	out	0x3d, r28	; 61
     6ae:	8c 01       	movw	r16, r24
    // Allocate modem struct memory
    memset(afsk, 0, sizeof(*afsk));
     6b0:	8a ec       	ldi	r24, 0xCA	; 202
     6b2:	d8 01       	movw	r26, r16
     6b4:	1d 92       	st	X+, r1
     6b6:	8a 95       	dec	r24
     6b8:	e9 f7       	brne	.-6      	; 0x6b4 <AFSK_init+0x1e>
    AFSK_modem = afsk;
     6ba:	10 93 61 08 	sts	0x0861, r17	; 0x800861 <AFSK_modem+0x1>
     6be:	00 93 60 08 	sts	0x0860, r16	; 0x800860 <AFSK_modem>
    // Set phase increment
    afsk->phaseInc = MARK_INC;
     6c2:	80 e4       	ldi	r24, 0x40	; 64
     6c4:	90 e0       	ldi	r25, 0x00	; 0
     6c6:	f8 01       	movw	r30, r16
     6c8:	96 8f       	std	Z+30, r25	; 0x1e
     6ca:	85 8f       	std	Z+29, r24	; 0x1d
    // Initialise FIFO buffers
    fifo_init(&afsk->delayFifo, (uint8_t *)afsk->delayBuf, sizeof(afsk->delayBuf));
     6cc:	c8 01       	movw	r24, r16
     6ce:	80 59       	subi	r24, 0x90	; 144
     6d0:	9f 4f       	sbci	r25, 0xFF	; 255
  }
  return c;
}

inline void fifo_init(FIFOBuffer *f, unsigned char *buffer, size_t size) {
  f->head = f->tail = f->begin = buffer;
     6d2:	e8 59       	subi	r30, 0x98	; 152
     6d4:	ff 4f       	sbci	r31, 0xFF	; 255
     6d6:	91 83       	std	Z+1, r25	; 0x01
     6d8:	80 83       	st	Z, r24
     6da:	97 83       	std	Z+7, r25	; 0x07
     6dc:	86 83       	std	Z+6, r24	; 0x06
     6de:	95 83       	std	Z+5, r25	; 0x05
     6e0:	84 83       	std	Z+4, r24	; 0x04
  f->end = buffer + size -1;
     6e2:	04 96       	adiw	r24, 0x04	; 4
     6e4:	93 83       	std	Z+3, r25	; 0x03
     6e6:	82 83       	std	Z+2, r24	; 0x02
    fifo_init(&afsk->rxFifo, afsk->rxBuf, sizeof(afsk->rxBuf));
     6e8:	09 96       	adiw	r24, 0x09	; 9
  }
  return c;
}

inline void fifo_init(FIFOBuffer *f, unsigned char *buffer, size_t size) {
  f->head = f->tail = f->begin = buffer;
     6ea:	d8 01       	movw	r26, r16
     6ec:	ab 58       	subi	r26, 0x8B	; 139
     6ee:	bf 4f       	sbci	r27, 0xFF	; 255
     6f0:	11 96       	adiw	r26, 0x01	; 1
     6f2:	9c 93       	st	X, r25
     6f4:	8e 93       	st	-X, r24
     6f6:	17 96       	adiw	r26, 0x07	; 7
     6f8:	9c 93       	st	X, r25
     6fa:	8e 93       	st	-X, r24
     6fc:	16 97       	sbiw	r26, 0x06	; 6
     6fe:	15 96       	adiw	r26, 0x05	; 5
     700:	9c 93       	st	X, r25
     702:	8e 93       	st	-X, r24
     704:	14 97       	sbiw	r26, 0x04	; 4
  f->end = buffer + size -1;
     706:	cf 96       	adiw	r24, 0x3f	; 63
     708:	13 96       	adiw	r26, 0x03	; 3
     70a:	9c 93       	st	X, r25
     70c:	8e 93       	st	-X, r24
     70e:	12 97       	sbiw	r26, 0x02	; 2
    fifo_init(&afsk->txFifo, afsk->txBuf, sizeof(afsk->txBuf));
     710:	85 59       	subi	r24, 0x95	; 149
     712:	91 09       	sbc	r25, r1
  }
  return c;
}

inline void fifo_init(FIFOBuffer *f, unsigned char *buffer, size_t size) {
  f->head = f->tail = f->begin = buffer;
     714:	d8 01       	movw	r26, r16
     716:	90 96       	adiw	r26, 0x20	; 32
     718:	9c 93       	st	X, r25
     71a:	8e 93       	st	-X, r24
     71c:	5f 97       	sbiw	r26, 0x1f	; 31
     71e:	96 96       	adiw	r26, 0x26	; 38
     720:	9c 93       	st	X, r25
     722:	8e 93       	st	-X, r24
     724:	95 97       	sbiw	r26, 0x25	; 37
     726:	94 96       	adiw	r26, 0x24	; 36
     728:	9c 93       	st	X, r25
     72a:	8e 93       	st	-X, r24
     72c:	93 97       	sbiw	r26, 0x23	; 35
  f->end = buffer + size -1;
     72e:	cf 96       	adiw	r24, 0x3f	; 63
     730:	92 96       	adiw	r26, 0x22	; 34
     732:	9c 93       	st	X, r25
     734:	8e 93       	st	-X, r24
     736:	91 97       	sbiw	r26, 0x21	; 33
     738:	84 e0       	ldi	r24, 0x04	; 4
     73a:	90 e0       	ldi	r25, 0x00	; 0
inline bool fifo_isfull(const FIFOBuffer *f) {
  return ((f->head == f->begin) && (f->tail == f->end)) || (f->tail == f->head - 1);
}

inline void fifo_push(FIFOBuffer *f, unsigned char c) {
  *(f->tail) = c;
     73c:	a6 81       	ldd	r26, Z+6	; 0x06
     73e:	b7 81       	ldd	r27, Z+7	; 0x07
     740:	1c 92       	st	X, r1
  
  if (f->tail == f->end) {
     742:	46 81       	ldd	r20, Z+6	; 0x06
     744:	57 81       	ldd	r21, Z+7	; 0x07
     746:	22 81       	ldd	r18, Z+2	; 0x02
     748:	33 81       	ldd	r19, Z+3	; 0x03
     74a:	42 17       	cp	r20, r18
     74c:	53 07       	cpc	r21, r19
     74e:	19 f4       	brne	.+6      	; 0x756 <AFSK_init+0xc0>
    f->tail = f->begin;
     750:	20 81       	ld	r18, Z
     752:	31 81       	ldd	r19, Z+1	; 0x01
     754:	04 c0       	rjmp	.+8      	; 0x75e <AFSK_init+0xc8>
  } else {
    f->tail++;
     756:	26 81       	ldd	r18, Z+6	; 0x06
     758:	37 81       	ldd	r19, Z+7	; 0x07
     75a:	2f 5f       	subi	r18, 0xFF	; 255
     75c:	3f 4f       	sbci	r19, 0xFF	; 255
     75e:	37 83       	std	Z+7, r19	; 0x07
     760:	26 83       	std	Z+6, r18	; 0x06
     762:	01 97       	sbiw	r24, 0x01	; 1

    // Fill delay FIFO with zeroes
    for (int i = 0; i<SAMPLESPERBIT / 2; i++) {
     764:	59 f7       	brne	.-42     	; 0x73c <AFSK_init+0xa6>
        fifo_push(&afsk->delayFifo, 0);
    }

    AFSK_hw_init();
     766:	0e 94 21 03 	call	0x642	; 0x642 <AFSK_hw_init>

    // Set up streams
    FILE afsk_fd = FDEV_SETUP_STREAM(afsk_putchar, afsk_getchar, _FDEV_SETUP_RW);
     76a:	8e e0       	ldi	r24, 0x0E	; 14
     76c:	fe 01       	movw	r30, r28
     76e:	31 96       	adiw	r30, 0x01	; 1
     770:	df 01       	movw	r26, r30
     772:	98 2f       	mov	r25, r24
     774:	1d 92       	st	X+, r1
     776:	9a 95       	dec	r25
     778:	e9 f7       	brne	.-6      	; 0x774 <AFSK_init+0xde>
    afsk->fd = afsk_fd;
     77a:	93 e0       	ldi	r25, 0x03	; 3
     77c:	9c 83       	std	Y+4, r25	; 0x04
     77e:	2a e5       	ldi	r18, 0x5A	; 90
     780:	32 e0       	ldi	r19, 0x02	; 2
     782:	3a 87       	std	Y+10, r19	; 0x0a
     784:	29 87       	std	Y+9, r18	; 0x09
     786:	2e ee       	ldi	r18, 0xEE	; 238
     788:	32 e0       	ldi	r19, 0x02	; 2
     78a:	3c 87       	std	Y+12, r19	; 0x0c
     78c:	2b 87       	std	Y+11, r18	; 0x0b
     78e:	d8 01       	movw	r26, r16
     790:	01 90       	ld	r0, Z+
     792:	0d 92       	st	X+, r0
     794:	8a 95       	dec	r24
     796:	e1 f7       	brne	.-8      	; 0x790 <AFSK_init+0xfa>
}
     798:	2e 96       	adiw	r28, 0x0e	; 14
     79a:	0f b6       	in	r0, 0x3f	; 63
     79c:	f8 94       	cli
     79e:	de bf       	out	0x3e, r29	; 62
     7a0:	0f be       	out	0x3f, r0	; 63
     7a2:	cd bf       	out	0x3d, r28	; 61
     7a4:	df 91       	pop	r29
     7a6:	cf 91       	pop	r28
     7a8:	1f 91       	pop	r17
     7aa:	0f 91       	pop	r16
     7ac:	08 95       	ret

000007ae <AFSK_transmit>:
    } else {
        return fifo_pop_locked(&AFSK_modem->rxFifo);
    }
}

void AFSK_transmit(char *buffer, size_t size) {
     7ae:	0f 93       	push	r16
     7b0:	1f 93       	push	r17
     7b2:	cf 93       	push	r28
     7b4:	df 93       	push	r29
    fifo_flush(&AFSK_modem->txFifo);
     7b6:	e0 91 60 08 	lds	r30, 0x0860	; 0x800860 <AFSK_modem>
     7ba:	f0 91 61 08 	lds	r31, 0x0861	; 0x800861 <AFSK_modem+0x1>
    return *(f->head++);
  }
}

inline void fifo_flush(FIFOBuffer *f) {
  f->head = f->tail;
     7be:	25 a1       	ldd	r18, Z+37	; 0x25
     7c0:	36 a1       	ldd	r19, Z+38	; 0x26
     7c2:	34 a3       	std	Z+36, r19	; 0x24
     7c4:	23 a3       	std	Z+35, r18	; 0x23
     7c6:	ec 01       	movw	r28, r24
     7c8:	8c 01       	movw	r16, r24
     7ca:	06 0f       	add	r16, r22
     7cc:	17 1f       	adc	r17, r23
    int i = 0;
    while (size--) {
     7ce:	c0 17       	cp	r28, r16
     7d0:	d1 07       	cpc	r29, r17
     7d2:	21 f0       	breq	.+8      	; 0x7dc <AFSK_transmit+0x2e>
        afsk_putchar(buffer[i++]);
     7d4:	89 91       	ld	r24, Y+
     7d6:	0e 94 5a 02 	call	0x4b4	; 0x4b4 <afsk_putchar>
     7da:	f9 cf       	rjmp	.-14     	; 0x7ce <AFSK_transmit+0x20>
    }
}
     7dc:	df 91       	pop	r29
     7de:	cf 91       	pop	r28
     7e0:	1f 91       	pop	r17
     7e2:	0f 91       	pop	r16
     7e4:	08 95       	ret

000007e6 <AFSK_dac_isr>:

uint8_t AFSK_dac_isr(Afsk *afsk) {
     7e6:	dc 01       	movw	r26, r24
    if (afsk->sampleIndex == 0) {
     7e8:	56 96       	adiw	r26, 0x16	; 22
     7ea:	8c 91       	ld	r24, X
     7ec:	56 97       	sbiw	r26, 0x16	; 22
     7ee:	81 11       	cpse	r24, r1
     7f0:	ec c0       	rjmp	.+472    	; 0x9ca <__stack+0xcb>
        if (afsk->txBit == 0) {
     7f2:	58 96       	adiw	r26, 0x18	; 24
     7f4:	8c 91       	ld	r24, X
     7f6:	58 97       	sbiw	r26, 0x18	; 24
     7f8:	81 11       	cpse	r24, r1
     7fa:	a2 c0       	rjmp	.+324    	; 0x940 <__stack+0x41>
  unsigned char * volatile head;
  unsigned char * volatile tail;
} FIFOBuffer;

inline bool fifo_isempty(const FIFOBuffer *f) {
  return f->head == f->tail;
     7fc:	93 96       	adiw	r26, 0x23	; 35
     7fe:	4d 91       	ld	r20, X+
     800:	5c 91       	ld	r21, X
     802:	94 97       	sbiw	r26, 0x24	; 36
     804:	95 96       	adiw	r26, 0x25	; 37
     806:	2d 91       	ld	r18, X+
     808:	3c 91       	ld	r19, X
     80a:	96 97       	sbiw	r26, 0x26	; 38
            if (fifo_isempty(&afsk->txFifo) && afsk->tailLength == 0) {
     80c:	42 17       	cp	r20, r18
     80e:	53 07       	cpc	r21, r19
     810:	39 f4       	brne	.+14     	; 0x820 <AFSK_dac_isr+0x3a>
     812:	54 96       	adiw	r26, 0x14	; 20
     814:	2d 91       	ld	r18, X+
     816:	3c 91       	ld	r19, X
     818:	55 97       	sbiw	r26, 0x15	; 21
     81a:	23 2b       	or	r18, r19
     81c:	09 f4       	brne	.+2      	; 0x820 <AFSK_dac_isr+0x3a>
     81e:	60 c0       	rjmp	.+192    	; 0x8e0 <AFSK_dac_isr+0xfa>
                AFSK_DAC_IRQ_STOP();
                afsk->sending = false;
                LED_TX_OFF();
                return 0;
            } else {
                if (!afsk->bitStuff) afsk->bitstuffCount = 0;
     820:	59 96       	adiw	r26, 0x19	; 25
     822:	9c 91       	ld	r25, X
     824:	59 97       	sbiw	r26, 0x19	; 25
     826:	91 11       	cpse	r25, r1
     828:	03 c0       	rjmp	.+6      	; 0x830 <AFSK_dac_isr+0x4a>
     82a:	5a 96       	adiw	r26, 0x1a	; 26
     82c:	1c 92       	st	X, r1
     82e:	5a 97       	sbiw	r26, 0x1a	; 26
                afsk->bitStuff = true;
     830:	91 e0       	ldi	r25, 0x01	; 1
     832:	59 96       	adiw	r26, 0x19	; 25
     834:	9c 93       	st	X, r25
     836:	59 97       	sbiw	r26, 0x19	; 25
                if (afsk->preambleLength == 0) {
     838:	52 96       	adiw	r26, 0x12	; 18
     83a:	2d 91       	ld	r18, X+
     83c:	3c 91       	ld	r19, X
     83e:	53 97       	sbiw	r26, 0x13	; 19
     840:	21 15       	cp	r18, r1
     842:	31 05       	cpc	r19, r1
     844:	99 f5       	brne	.+102    	; 0x8ac <AFSK_dac_isr+0xc6>
     846:	93 96       	adiw	r26, 0x23	; 35
     848:	4d 91       	ld	r20, X+
     84a:	5c 91       	ld	r21, X
     84c:	94 97       	sbiw	r26, 0x24	; 36
     84e:	95 96       	adiw	r26, 0x25	; 37
     850:	2d 91       	ld	r18, X+
     852:	3c 91       	ld	r19, X
     854:	96 97       	sbiw	r26, 0x26	; 38
                    if (fifo_isempty(&afsk->txFifo)) {
     856:	42 17       	cp	r20, r18
     858:	53 07       	cpc	r21, r19
     85a:	59 f4       	brne	.+22     	; 0x872 <AFSK_dac_isr+0x8c>
                        afsk->tailLength--;
     85c:	54 96       	adiw	r26, 0x14	; 20
     85e:	2d 91       	ld	r18, X+
     860:	3c 91       	ld	r19, X
     862:	55 97       	sbiw	r26, 0x15	; 21
     864:	21 50       	subi	r18, 0x01	; 1
     866:	31 09       	sbc	r19, r1
     868:	55 96       	adiw	r26, 0x15	; 21
     86a:	3c 93       	st	X, r19
     86c:	2e 93       	st	-X, r18
     86e:	54 97       	sbiw	r26, 0x14	; 20
     870:	23 c0       	rjmp	.+70     	; 0x8b8 <AFSK_dac_isr+0xd2>
    f->tail++;
  }
}

inline unsigned char fifo_pop(FIFOBuffer *f) {
  if(f->head == f->end) {
     872:	93 96       	adiw	r26, 0x23	; 35
     874:	ed 91       	ld	r30, X+
     876:	fc 91       	ld	r31, X
     878:	94 97       	sbiw	r26, 0x24	; 36
     87a:	91 96       	adiw	r26, 0x21	; 33
     87c:	2d 91       	ld	r18, X+
     87e:	3c 91       	ld	r19, X
     880:	92 97       	sbiw	r26, 0x22	; 34
     882:	e2 17       	cp	r30, r18
     884:	f3 07       	cpc	r31, r19
     886:	29 f4       	brne	.+10     	; 0x892 <AFSK_dac_isr+0xac>
    f->head = f->begin;
     888:	5f 96       	adiw	r26, 0x1f	; 31
     88a:	2d 91       	ld	r18, X+
     88c:	3c 91       	ld	r19, X
     88e:	90 97       	sbiw	r26, 0x20	; 32
     890:	07 c0       	rjmp	.+14     	; 0x8a0 <AFSK_dac_isr+0xba>
    return *(f->end);
  } else {
    return *(f->head++);
     892:	93 96       	adiw	r26, 0x23	; 35
     894:	ed 91       	ld	r30, X+
     896:	fc 91       	ld	r31, X
     898:	94 97       	sbiw	r26, 0x24	; 36
     89a:	9f 01       	movw	r18, r30
     89c:	2f 5f       	subi	r18, 0xFF	; 255
     89e:	3f 4f       	sbci	r19, 0xFF	; 255
     8a0:	94 96       	adiw	r26, 0x24	; 36
     8a2:	3c 93       	st	X, r19
     8a4:	2e 93       	st	-X, r18
     8a6:	93 97       	sbiw	r26, 0x23	; 35
     8a8:	90 81       	ld	r25, Z
     8aa:	07 c0       	rjmp	.+14     	; 0x8ba <AFSK_dac_isr+0xd4>
                        afsk->currentOutputByte = HDLC_FLAG;
                    } else {
                        afsk->currentOutputByte = fifo_pop(&afsk->txFifo);
                    }
                } else {
                    afsk->preambleLength--;
     8ac:	21 50       	subi	r18, 0x01	; 1
     8ae:	31 09       	sbc	r19, r1
     8b0:	53 96       	adiw	r26, 0x13	; 19
     8b2:	3c 93       	st	X, r19
     8b4:	2e 93       	st	-X, r18
     8b6:	52 97       	sbiw	r26, 0x12	; 18
                    afsk->currentOutputByte = HDLC_FLAG;
     8b8:	9e e7       	ldi	r25, 0x7E	; 126
     8ba:	57 96       	adiw	r26, 0x17	; 23
     8bc:	9c 93       	st	X, r25
     8be:	57 97       	sbiw	r26, 0x17	; 23
                }
                if (afsk->currentOutputByte == AX25_ESC) {
     8c0:	57 96       	adiw	r26, 0x17	; 23
     8c2:	9c 91       	ld	r25, X
     8c4:	57 97       	sbiw	r26, 0x17	; 23
     8c6:	9b 31       	cpi	r25, 0x1B	; 27
     8c8:	89 f5       	brne	.+98     	; 0x92c <__stack+0x2d>
  unsigned char * volatile head;
  unsigned char * volatile tail;
} FIFOBuffer;

inline bool fifo_isempty(const FIFOBuffer *f) {
  return f->head == f->tail;
     8ca:	93 96       	adiw	r26, 0x23	; 35
     8cc:	4d 91       	ld	r20, X+
     8ce:	5c 91       	ld	r21, X
     8d0:	94 97       	sbiw	r26, 0x24	; 36
     8d2:	95 96       	adiw	r26, 0x25	; 37
     8d4:	2d 91       	ld	r18, X+
     8d6:	3c 91       	ld	r19, X
     8d8:	96 97       	sbiw	r26, 0x26	; 38
                    if (fifo_isempty(&afsk->txFifo)) {
     8da:	42 17       	cp	r20, r18
     8dc:	53 07       	cpc	r21, r19
     8de:	39 f4       	brne	.+14     	; 0x8ee <AFSK_dac_isr+0x108>
                        AFSK_DAC_IRQ_STOP();
     8e0:	10 92 19 01 	sts	0x0119, r1	; 0x800119 <hw_afsk_dac_isr>
                        afsk->sending = false;
     8e4:	a9 59       	subi	r26, 0x99	; 153
     8e6:	bf 4f       	sbci	r27, 0xFF	; 255
     8e8:	1c 92       	st	X, r1
                        LED_TX_OFF();
     8ea:	29 98       	cbi	0x05, 1	; 5
                        return 0;
     8ec:	08 95       	ret
    f->tail++;
  }
}

inline unsigned char fifo_pop(FIFOBuffer *f) {
  if(f->head == f->end) {
     8ee:	93 96       	adiw	r26, 0x23	; 35
     8f0:	ed 91       	ld	r30, X+
     8f2:	fc 91       	ld	r31, X
     8f4:	94 97       	sbiw	r26, 0x24	; 36
     8f6:	91 96       	adiw	r26, 0x21	; 33
     8f8:	8d 91       	ld	r24, X+
     8fa:	9c 91       	ld	r25, X
     8fc:	92 97       	sbiw	r26, 0x22	; 34
     8fe:	e8 17       	cp	r30, r24
     900:	f9 07       	cpc	r31, r25
     902:	29 f4       	brne	.+10     	; 0x90e <__stack+0xf>
    f->head = f->begin;
     904:	5f 96       	adiw	r26, 0x1f	; 31
     906:	8d 91       	ld	r24, X+
     908:	9c 91       	ld	r25, X
     90a:	90 97       	sbiw	r26, 0x20	; 32
     90c:	06 c0       	rjmp	.+12     	; 0x91a <__stack+0x1b>
    return *(f->end);
  } else {
    return *(f->head++);
     90e:	93 96       	adiw	r26, 0x23	; 35
     910:	ed 91       	ld	r30, X+
     912:	fc 91       	ld	r31, X
     914:	94 97       	sbiw	r26, 0x24	; 36
     916:	cf 01       	movw	r24, r30
     918:	01 96       	adiw	r24, 0x01	; 1
     91a:	94 96       	adiw	r26, 0x24	; 36
     91c:	9c 93       	st	X, r25
     91e:	8e 93       	st	-X, r24
     920:	93 97       	sbiw	r26, 0x23	; 35
     922:	80 81       	ld	r24, Z
                    } else {
                        afsk->currentOutputByte = fifo_pop(&afsk->txFifo);
     924:	57 96       	adiw	r26, 0x17	; 23
     926:	8c 93       	st	X, r24
     928:	57 97       	sbiw	r26, 0x17	; 23
     92a:	06 c0       	rjmp	.+12     	; 0x938 <__stack+0x39>
                    }
                } else if (afsk->currentOutputByte == HDLC_FLAG || afsk->currentOutputByte == HDLC_RESET) {
     92c:	9e 57       	subi	r25, 0x7E	; 126
     92e:	92 30       	cpi	r25, 0x02	; 2
     930:	18 f4       	brcc	.+6      	; 0x938 <__stack+0x39>
                    afsk->bitStuff = false;
     932:	59 96       	adiw	r26, 0x19	; 25
     934:	1c 92       	st	X, r1
     936:	59 97       	sbiw	r26, 0x19	; 25
                }
            }
            afsk->txBit = 0x01;
     938:	81 e0       	ldi	r24, 0x01	; 1
     93a:	58 96       	adiw	r26, 0x18	; 24
     93c:	8c 93       	st	X, r24
     93e:	58 97       	sbiw	r26, 0x18	; 24
        }

        if (afsk->bitStuff && afsk->bitstuffCount >= BIT_STUFF_LEN) {
     940:	59 96       	adiw	r26, 0x19	; 25
     942:	8c 91       	ld	r24, X
     944:	59 97       	sbiw	r26, 0x19	; 25
     946:	5d 96       	adiw	r26, 0x1d	; 29
     948:	2d 91       	ld	r18, X+
     94a:	3c 91       	ld	r19, X
     94c:	5e 97       	sbiw	r26, 0x1e	; 30
     94e:	88 23       	and	r24, r24
     950:	a9 f0       	breq	.+42     	; 0x97c <__stack+0x7d>
     952:	5a 96       	adiw	r26, 0x1a	; 26
     954:	8c 91       	ld	r24, X
     956:	5a 97       	sbiw	r26, 0x1a	; 26
     958:	85 30       	cpi	r24, 0x05	; 5
     95a:	80 f0       	brcs	.+32     	; 0x97c <__stack+0x7d>
            afsk->bitstuffCount = 0;
     95c:	5a 96       	adiw	r26, 0x1a	; 26
     95e:	1c 92       	st	X, r1
     960:	5a 97       	sbiw	r26, 0x1a	; 26
            afsk->phaseInc = SWITCH_TONE(afsk->phaseInc);
     962:	20 34       	cpi	r18, 0x40	; 64
     964:	31 05       	cpc	r19, r1
     966:	19 f0       	breq	.+6      	; 0x96e <__stack+0x6f>
     968:	80 e4       	ldi	r24, 0x40	; 64
     96a:	90 e0       	ldi	r25, 0x00	; 0
     96c:	02 c0       	rjmp	.+4      	; 0x972 <__stack+0x73>
     96e:	85 e7       	ldi	r24, 0x75	; 117
     970:	90 e0       	ldi	r25, 0x00	; 0
     972:	5e 96       	adiw	r26, 0x1e	; 30
     974:	9c 93       	st	X, r25
     976:	8e 93       	st	-X, r24
     978:	5d 97       	sbiw	r26, 0x1d	; 29
     97a:	23 c0       	rjmp	.+70     	; 0x9c2 <__stack+0xc3>
        } else {
            if (afsk->currentOutputByte & afsk->txBit) {
     97c:	58 96       	adiw	r26, 0x18	; 24
     97e:	8c 91       	ld	r24, X
     980:	58 97       	sbiw	r26, 0x18	; 24
     982:	57 96       	adiw	r26, 0x17	; 23
     984:	9c 91       	ld	r25, X
     986:	57 97       	sbiw	r26, 0x17	; 23
     988:	98 23       	and	r25, r24
     98a:	41 f0       	breq	.+16     	; 0x99c <__stack+0x9d>
                afsk->bitstuffCount++;
     98c:	5a 96       	adiw	r26, 0x1a	; 26
     98e:	9c 91       	ld	r25, X
     990:	5a 97       	sbiw	r26, 0x1a	; 26
     992:	9f 5f       	subi	r25, 0xFF	; 255
     994:	5a 96       	adiw	r26, 0x1a	; 26
     996:	9c 93       	st	X, r25
     998:	5a 97       	sbiw	r26, 0x1a	; 26
     99a:	0f c0       	rjmp	.+30     	; 0x9ba <__stack+0xbb>
            } else {
                afsk->bitstuffCount = 0;
     99c:	5a 96       	adiw	r26, 0x1a	; 26
     99e:	1c 92       	st	X, r1
     9a0:	5a 97       	sbiw	r26, 0x1a	; 26
                afsk->phaseInc = SWITCH_TONE(afsk->phaseInc);
     9a2:	20 34       	cpi	r18, 0x40	; 64
     9a4:	31 05       	cpc	r19, r1
     9a6:	19 f0       	breq	.+6      	; 0x9ae <__stack+0xaf>
     9a8:	20 e4       	ldi	r18, 0x40	; 64
     9aa:	30 e0       	ldi	r19, 0x00	; 0
     9ac:	02 c0       	rjmp	.+4      	; 0x9b2 <__stack+0xb3>
     9ae:	25 e7       	ldi	r18, 0x75	; 117
     9b0:	30 e0       	ldi	r19, 0x00	; 0
     9b2:	5e 96       	adiw	r26, 0x1e	; 30
     9b4:	3c 93       	st	X, r19
     9b6:	2e 93       	st	-X, r18
     9b8:	5d 97       	sbiw	r26, 0x1d	; 29
            }
            afsk->txBit <<= 1;
     9ba:	88 0f       	add	r24, r24
     9bc:	58 96       	adiw	r26, 0x18	; 24
     9be:	8c 93       	st	X, r24
     9c0:	58 97       	sbiw	r26, 0x18	; 24
        }

        afsk->sampleIndex = SAMPLESPERBIT;
     9c2:	88 e0       	ldi	r24, 0x08	; 8
     9c4:	56 96       	adiw	r26, 0x16	; 22
     9c6:	8c 93       	st	X, r24
     9c8:	56 97       	sbiw	r26, 0x16	; 22
    }

    afsk->phaseAcc += afsk->phaseInc;
     9ca:	5d 96       	adiw	r26, 0x1d	; 29
     9cc:	ed 91       	ld	r30, X+
     9ce:	fc 91       	ld	r31, X
     9d0:	5e 97       	sbiw	r26, 0x1e	; 30
     9d2:	5b 96       	adiw	r26, 0x1b	; 27
     9d4:	8d 91       	ld	r24, X+
     9d6:	9c 91       	ld	r25, X
     9d8:	5c 97       	sbiw	r26, 0x1c	; 28
     9da:	e8 0f       	add	r30, r24
     9dc:	f9 1f       	adc	r31, r25
    afsk->phaseAcc %= SIN_LEN;
     9de:	9f 01       	movw	r18, r30
     9e0:	31 70       	andi	r19, 0x01	; 1
     9e2:	5c 96       	adiw	r26, 0x1c	; 28
     9e4:	3c 93       	st	X, r19
     9e6:	2e 93       	st	-X, r18
     9e8:	5b 97       	sbiw	r26, 0x1b	; 27
    afsk->sampleIndex--;
     9ea:	56 96       	adiw	r26, 0x16	; 22
     9ec:	8c 91       	ld	r24, X
     9ee:	56 97       	sbiw	r26, 0x16	; 22
     9f0:	81 50       	subi	r24, 0x01	; 1
     9f2:	56 96       	adiw	r26, 0x16	; 22
     9f4:	8c 93       	st	X, r24
    245, 246, 246, 247, 248, 248, 249, 249, 250, 250, 250, 251, 251, 252, 252, 252,
    253, 253, 253, 253, 254, 254, 254, 254, 254, 255, 255, 255, 255, 255, 255, 255,
};

inline static uint8_t sinSample(uint16_t i) {
    uint16_t newI = i % (SIN_LEN/2);
     9f6:	ff 27       	eor	r31, r31
    newI = (newI >= (SIN_LEN/4)) ? (SIN_LEN/2 - newI -1) : newI;
     9f8:	e0 38       	cpi	r30, 0x80	; 128
     9fa:	f1 05       	cpc	r31, r1
     9fc:	30 f0       	brcs	.+12     	; 0xa0a <__stack+0x10b>
     9fe:	8f ef       	ldi	r24, 0xFF	; 255
     a00:	90 e0       	ldi	r25, 0x00	; 0
     a02:	ac 01       	movw	r20, r24
     a04:	4e 1b       	sub	r20, r30
     a06:	5f 0b       	sbc	r21, r31
     a08:	fa 01       	movw	r30, r20
    uint8_t sine = pgm_read_byte(&sin_table[newI]);
     a0a:	e3 51       	subi	r30, 0x13	; 19
     a0c:	ff 4f       	sbci	r31, 0xFF	; 255
     a0e:	84 91       	lpm	r24, Z
    return (i >= (SIN_LEN/2)) ? (255 - sine) : sine;
     a10:	2f 3f       	cpi	r18, 0xFF	; 255
     a12:	31 05       	cpc	r19, r1
     a14:	11 f0       	breq	.+4      	; 0xa1a <__stack+0x11b>
     a16:	08 f0       	brcs	.+2      	; 0xa1a <__stack+0x11b>
     a18:	80 95       	com	r24

    return sinSample(afsk->phaseAcc);
}
     a1a:	08 95       	ret

00000a1c <AFSK_adc_isr>:
    //digitalWrite(13, LOW);
    return ret;
}


void AFSK_adc_isr(Afsk *afsk, int8_t currentSample) {
     a1c:	ef 92       	push	r14
     a1e:	ff 92       	push	r15
     a20:	0f 93       	push	r16
     a22:	1f 93       	push	r17
     a24:	cf 93       	push	r28
     a26:	df 93       	push	r29
     a28:	fc 01       	movw	r30, r24
    // a sample delayed by (samples per bit / 2).
    // We then lowpass-filter the samples with a
    // Chebyshev filter. The lowpass filtering serves
    // to "smooth out" the variations in the samples.

    afsk->iirX[0] = afsk->iirX[1];
     a2a:	8c 01       	movw	r16, r24
     a2c:	01 54       	subi	r16, 0x41	; 65
     a2e:	1f 4f       	sbci	r17, 0xFF	; 255
     a30:	d8 01       	movw	r26, r16
     a32:	4d 91       	ld	r20, X+
     a34:	5c 91       	ld	r21, X
     a36:	11 97       	sbiw	r26, 0x01	; 1
     a38:	12 97       	sbiw	r26, 0x02	; 2
     a3a:	11 96       	adiw	r26, 0x01	; 1
     a3c:	5c 93       	st	X, r21
     a3e:	4e 93       	st	-X, r20
    f->tail++;
  }
}

inline unsigned char fifo_pop(FIFOBuffer *f) {
  if(f->head == f->end) {
     a40:	a5 55       	subi	r26, 0x55	; 85
     a42:	b1 09       	sbc	r27, r1
     a44:	14 96       	adiw	r26, 0x04	; 4
     a46:	8d 91       	ld	r24, X+
     a48:	9c 91       	ld	r25, X
     a4a:	15 97       	sbiw	r26, 0x05	; 5
     a4c:	12 96       	adiw	r26, 0x02	; 2
     a4e:	2d 91       	ld	r18, X+
     a50:	3c 91       	ld	r19, X
     a52:	13 97       	sbiw	r26, 0x03	; 3
     a54:	82 17       	cp	r24, r18
     a56:	93 07       	cpc	r25, r19
     a58:	21 f4       	brne	.+8      	; 0xa62 <AFSK_adc_isr+0x46>
    f->head = f->begin;
     a5a:	2d 91       	ld	r18, X+
     a5c:	3c 91       	ld	r19, X
     a5e:	11 97       	sbiw	r26, 0x01	; 1
     a60:	07 c0       	rjmp	.+14     	; 0xa70 <AFSK_adc_isr+0x54>
    return *(f->end);
  } else {
    return *(f->head++);
     a62:	14 96       	adiw	r26, 0x04	; 4
     a64:	8d 91       	ld	r24, X+
     a66:	9c 91       	ld	r25, X
     a68:	15 97       	sbiw	r26, 0x05	; 5
     a6a:	9c 01       	movw	r18, r24
     a6c:	2f 5f       	subi	r18, 0xFF	; 255
     a6e:	3f 4f       	sbci	r19, 0xFF	; 255
     a70:	15 96       	adiw	r26, 0x05	; 5
     a72:	3c 93       	st	X, r19
     a74:	2e 93       	st	-X, r18
     a76:	14 97       	sbiw	r26, 0x04	; 4
     a78:	ec 01       	movw	r28, r24
     a7a:	28 81       	ld	r18, Y

    #if FILTER_CUTOFF == 600
        afsk->iirX[1] = ((int8_t)fifo_pop(&afsk->delayFifo) * currentSample) >> 2;
     a7c:	26 02       	muls	r18, r22
     a7e:	90 01       	movw	r18, r0
     a80:	11 24       	eor	r1, r1
     a82:	c9 01       	movw	r24, r18
     a84:	95 95       	asr	r25
     a86:	87 95       	ror	r24
     a88:	95 95       	asr	r25
     a8a:	87 95       	ror	r24
     a8c:	e8 01       	movw	r28, r16
     a8e:	99 83       	std	Y+1, r25	; 0x01
     a90:	88 83       	st	Y, r24
        // afsk->iirX[1] = ((int8_t)fifo_pop(&afsk->delayFifo) * currentSample) / 1.881349100;
    #else
        #error Unsupported filter cutoff!
    #endif

    afsk->iirY[0] = afsk->iirY[1];
     a92:	7f 01       	movw	r14, r30
     a94:	d3 ec       	ldi	r29, 0xC3	; 195
     a96:	ed 0e       	add	r14, r29
     a98:	f1 1c       	adc	r15, r1
     a9a:	e7 01       	movw	r28, r14
     a9c:	28 81       	ld	r18, Y
     a9e:	39 81       	ldd	r19, Y+1	; 0x01
     aa0:	8f 01       	movw	r16, r30
     aa2:	0f 53       	subi	r16, 0x3F	; 63
     aa4:	1f 4f       	sbci	r17, 0xFF	; 255
     aa6:	e8 01       	movw	r28, r16
     aa8:	39 83       	std	Y+1, r19	; 0x01
     aaa:	28 83       	st	Y, r18
    
    #if FILTER_CUTOFF == 600
        afsk->iirY[1] = afsk->iirX[0] + afsk->iirX[1] + (afsk->iirY[0] >> 1);
     aac:	84 0f       	add	r24, r20
     aae:	95 1f       	adc	r25, r21
     ab0:	35 95       	asr	r19
     ab2:	27 95       	ror	r18
     ab4:	82 0f       	add	r24, r18
     ab6:	93 1f       	adc	r25, r19
     ab8:	e7 01       	movw	r28, r14
     aba:	99 83       	std	Y+1, r25	; 0x01
     abc:	88 83       	st	Y, r24

    // We put the sampled bit in a delay-line:
    // First we bitshift everything 1 left
    afsk->sampledBits <<= 1;
    // And then add the sampled bit to our delay line
    afsk->sampledBits |= (afsk->iirY[1] > 0) ? 0 : 1;
     abe:	af 01       	movw	r20, r30
     ac0:	4b 53       	subi	r20, 0x3B	; 59
     ac2:	5f 4f       	sbci	r21, 0xFF	; 255
     ac4:	21 e0       	ldi	r18, 0x01	; 1
     ac6:	18 16       	cp	r1, r24
     ac8:	19 06       	cpc	r1, r25
     aca:	0c f4       	brge	.+2      	; 0xace <AFSK_adc_isr+0xb2>
     acc:	20 e0       	ldi	r18, 0x00	; 0
    #endif


    // We put the sampled bit in a delay-line:
    // First we bitshift everything 1 left
    afsk->sampledBits <<= 1;
     ace:	ea 01       	movw	r28, r20
     ad0:	88 81       	ld	r24, Y
     ad2:	88 0f       	add	r24, r24
    // And then add the sampled bit to our delay line
    afsk->sampledBits |= (afsk->iirY[1] > 0) ? 0 : 1;
     ad4:	82 2b       	or	r24, r18
     ad6:	88 83       	st	Y, r24
inline bool fifo_isfull(const FIFOBuffer *f) {
  return ((f->head == f->begin) && (f->tail == f->end)) || (f->tail == f->head - 1);
}

inline void fifo_push(FIFOBuffer *f, unsigned char c) {
  *(f->tail) = c;
     ad8:	16 96       	adiw	r26, 0x06	; 6
     ada:	8d 91       	ld	r24, X+
     adc:	9c 91       	ld	r25, X
     ade:	17 97       	sbiw	r26, 0x07	; 7
     ae0:	ec 01       	movw	r28, r24
     ae2:	68 83       	st	Y, r22
  
  if (f->tail == f->end) {
     ae4:	16 96       	adiw	r26, 0x06	; 6
     ae6:	2d 91       	ld	r18, X+
     ae8:	3c 91       	ld	r19, X
     aea:	17 97       	sbiw	r26, 0x07	; 7
     aec:	12 96       	adiw	r26, 0x02	; 2
     aee:	8d 91       	ld	r24, X+
     af0:	9c 91       	ld	r25, X
     af2:	13 97       	sbiw	r26, 0x03	; 3
     af4:	28 17       	cp	r18, r24
     af6:	39 07       	cpc	r19, r25
     af8:	21 f4       	brne	.+8      	; 0xb02 <AFSK_adc_isr+0xe6>
    f->tail = f->begin;
     afa:	8d 91       	ld	r24, X+
     afc:	9c 91       	ld	r25, X
     afe:	11 97       	sbiw	r26, 0x01	; 1
     b00:	05 c0       	rjmp	.+10     	; 0xb0c <AFSK_adc_isr+0xf0>
  } else {
    f->tail++;
     b02:	16 96       	adiw	r26, 0x06	; 6
     b04:	8d 91       	ld	r24, X+
     b06:	9c 91       	ld	r25, X
     b08:	17 97       	sbiw	r26, 0x07	; 7
     b0a:	01 96       	adiw	r24, 0x01	; 1
     b0c:	17 96       	adiw	r26, 0x07	; 7
     b0e:	9c 93       	st	X, r25
     b10:	8e 93       	st	-X, r24
     b12:	16 97       	sbiw	r26, 0x06	; 6
    // than half of PHASE_MAX, we move it forward a little.
    // This way, our "window" is constantly seeking to position
    // it's center at the bit transitions. Thus, we synchronise
    // our timing to the transmitter, even if it's timing is
    // a little off compared to our own.
    if (SIGNAL_TRANSITIONED(afsk->sampledBits)) {
     b14:	da 01       	movw	r26, r20
     b16:	9c 91       	ld	r25, X
     b18:	89 2f       	mov	r24, r25
     b1a:	86 95       	lsr	r24
     b1c:	86 95       	lsr	r24
     b1e:	89 27       	eor	r24, r25
     b20:	83 70       	andi	r24, 0x03	; 3
     b22:	df 01       	movw	r26, r30
     b24:	aa 53       	subi	r26, 0x3A	; 58
     b26:	bf 4f       	sbci	r27, 0xFF	; 255
     b28:	83 30       	cpi	r24, 0x03	; 3
     b2a:	39 f4       	brne	.+14     	; 0xb3a <AFSK_adc_isr+0x11e>
        if (afsk->currentPhase < PHASE_THRESHOLD) {
     b2c:	8c 91       	ld	r24, X
     b2e:	80 32       	cpi	r24, 0x20	; 32
     b30:	14 f4       	brge	.+4      	; 0xb36 <AFSK_adc_isr+0x11a>
            afsk->currentPhase += PHASE_INC;
     b32:	8f 5f       	subi	r24, 0xFF	; 255
     b34:	01 c0       	rjmp	.+2      	; 0xb38 <AFSK_adc_isr+0x11c>
        } else {
            afsk->currentPhase -= PHASE_INC;
     b36:	81 50       	subi	r24, 0x01	; 1
     b38:	8c 93       	st	X, r24
        }
    }

    // We increment our phase counter
    afsk->currentPhase += PHASE_BITS;
     b3a:	8c 91       	ld	r24, X
     b3c:	88 5f       	subi	r24, 0xF8	; 248

    // Check if we have reached the end of
    // our sampling window.
    if (afsk->currentPhase >= PHASE_MAX) {
     b3e:	80 34       	cpi	r24, 0x40	; 64
     b40:	14 f4       	brge	.+4      	; 0xb46 <AFSK_adc_isr+0x12a>
            afsk->currentPhase -= PHASE_INC;
        }
    }

    // We increment our phase counter
    afsk->currentPhase += PHASE_BITS;
     b42:	8c 93       	st	X, r24
     b44:	46 c1       	rjmp	.+652    	; 0xdd2 <AFSK_adc_isr+0x3b6>
    // Check if we have reached the end of
    // our sampling window.
    if (afsk->currentPhase >= PHASE_MAX) {
        // If we have, wrap around our phase
        // counter by modulus
        afsk->currentPhase %= PHASE_MAX;
     b46:	8f 73       	andi	r24, 0x3F	; 63
     b48:	8c 93       	st	X, r24

        // Bitshift to make room for the next
        // bit in our stream of demodulated bits
        afsk->actualBits <<= 1;
     b4a:	df 01       	movw	r26, r30
     b4c:	a9 53       	subi	r26, 0x39	; 57
     b4e:	bf 4f       	sbci	r27, 0xFF	; 255
     b50:	8c 91       	ld	r24, X
     b52:	88 0f       	add	r24, r24

        // We determine the actual bit value by reading
        // the last 3 sampled bits. If there is three or
        // more 1's, we will assume that the transmitter
        // sent us a one, otherwise we assume a zero
        uint8_t bits = afsk->sampledBits & 0x07;
     b54:	97 70       	andi	r25, 0x07	; 7
        if (bits == 0x07 || // 111
            bits == 0x06 || // 110
     b56:	2b ef       	ldi	r18, 0xFB	; 251
     b58:	29 0f       	add	r18, r25
        // We determine the actual bit value by reading
        // the last 3 sampled bits. If there is three or
        // more 1's, we will assume that the transmitter
        // sent us a one, otherwise we assume a zero
        uint8_t bits = afsk->sampledBits & 0x07;
        if (bits == 0x07 || // 111
     b5a:	23 30       	cpi	r18, 0x03	; 3
     b5c:	10 f0       	brcs	.+4      	; 0xb62 <AFSK_adc_isr+0x146>
            bits == 0x06 || // 110
            bits == 0x05 || // 101
     b5e:	93 30       	cpi	r25, 0x03	; 3
     b60:	09 f4       	brne	.+2      	; 0xb64 <AFSK_adc_isr+0x148>
            bits == 0x03    // 011
            ) {
            afsk->actualBits |= 1;
     b62:	81 60       	ori	r24, 0x01	; 1
     b64:	8c 93       	st	X, r24
        // that we can use to synchronize our phase.
        //
        // We also check the return of the Link Control parser
        // to check if an error occured.

        if (!hdlcParse(&afsk->hdlc, !TRANSITION_FOUND(afsk->actualBits), &afsk->rxFifo)) {
     b66:	8c 91       	ld	r24, X
     b68:	98 2f       	mov	r25, r24
     b6a:	96 95       	lsr	r25
     b6c:	89 27       	eor	r24, r25
     b6e:	80 95       	com	r24
     b70:	81 70       	andi	r24, 0x01	; 1
    bool ret = true;

    // Bitshift our byte of demodulated bits to
    // the left by one bit, to make room for the
    // next incoming bit
    hdlc->demodulatedBits <<= 1;
     b72:	96 85       	ldd	r25, Z+14	; 0x0e
     b74:	99 0f       	add	r25, r25
    // And then put the newest bit from the 
    // demodulator into the byte.
    hdlc->demodulatedBits |= bit ? 1 : 0;
     b76:	89 2b       	or	r24, r25
     b78:	86 87       	std	Z+14, r24	; 0x0e

    // Now we'll look at the last 8 received bits, and
    // check if we have received a HDLC flag (01111110)
    if (hdlc->demodulatedBits == HDLC_FLAG) {
     b7a:	8e 37       	cpi	r24, 0x7E	; 126
     b7c:	09 f0       	breq	.+2      	; 0xb80 <AFSK_adc_isr+0x164>
     b7e:	48 c0       	rjmp	.+144    	; 0xc10 <AFSK_adc_isr+0x1f4>
inline bool fifo_isempty(const FIFOBuffer *f) {
  return f->head == f->tail;
}

inline bool fifo_isfull(const FIFOBuffer *f) {
  return ((f->head == f->begin) && (f->tail == f->end)) || (f->tail == f->head - 1);
     b80:	df 01       	movw	r26, r30
     b82:	ab 58       	subi	r26, 0x8B	; 139
     b84:	bf 4f       	sbci	r27, 0xFF	; 255
     b86:	14 96       	adiw	r26, 0x04	; 4
     b88:	2d 91       	ld	r18, X+
     b8a:	3c 91       	ld	r19, X
     b8c:	15 97       	sbiw	r26, 0x05	; 5
     b8e:	8d 91       	ld	r24, X+
     b90:	9c 91       	ld	r25, X
     b92:	11 97       	sbiw	r26, 0x01	; 1
     b94:	28 17       	cp	r18, r24
     b96:	39 07       	cpc	r19, r25
     b98:	61 f4       	brne	.+24     	; 0xbb2 <AFSK_adc_isr+0x196>
     b9a:	16 96       	adiw	r26, 0x06	; 6
     b9c:	2d 91       	ld	r18, X+
     b9e:	3c 91       	ld	r19, X
     ba0:	17 97       	sbiw	r26, 0x07	; 7
     ba2:	12 96       	adiw	r26, 0x02	; 2
     ba4:	8d 91       	ld	r24, X+
     ba6:	9c 91       	ld	r25, X
     ba8:	13 97       	sbiw	r26, 0x03	; 3
     baa:	28 17       	cp	r18, r24
     bac:	39 07       	cpc	r19, r25
     bae:	09 f4       	brne	.+2      	; 0xbb2 <AFSK_adc_isr+0x196>
     bb0:	dc c0       	rjmp	.+440    	; 0xd6a <AFSK_adc_isr+0x34e>
     bb2:	16 96       	adiw	r26, 0x06	; 6
     bb4:	2d 91       	ld	r18, X+
     bb6:	3c 91       	ld	r19, X
     bb8:	17 97       	sbiw	r26, 0x07	; 7
     bba:	14 96       	adiw	r26, 0x04	; 4
     bbc:	8d 91       	ld	r24, X+
     bbe:	9c 91       	ld	r25, X
     bc0:	15 97       	sbiw	r26, 0x05	; 5
     bc2:	01 97       	sbiw	r24, 0x01	; 1
        // If we have, check that our output buffer is
        // not full.
        if (!fifo_isfull(fifo)) {
     bc4:	28 17       	cp	r18, r24
     bc6:	39 07       	cpc	r19, r25
     bc8:	09 f4       	brne	.+2      	; 0xbcc <AFSK_adc_isr+0x1b0>
     bca:	cf c0       	rjmp	.+414    	; 0xd6a <AFSK_adc_isr+0x34e>
}

inline void fifo_push(FIFOBuffer *f, unsigned char c) {
  *(f->tail) = c;
     bcc:	16 96       	adiw	r26, 0x06	; 6
     bce:	cd 91       	ld	r28, X+
     bd0:	dc 91       	ld	r29, X
     bd2:	17 97       	sbiw	r26, 0x07	; 7
     bd4:	8e e7       	ldi	r24, 0x7E	; 126
     bd6:	88 83       	st	Y, r24
  
  if (f->tail == f->end) {
     bd8:	16 96       	adiw	r26, 0x06	; 6
     bda:	2d 91       	ld	r18, X+
     bdc:	3c 91       	ld	r19, X
     bde:	17 97       	sbiw	r26, 0x07	; 7
     be0:	12 96       	adiw	r26, 0x02	; 2
     be2:	8d 91       	ld	r24, X+
     be4:	9c 91       	ld	r25, X
     be6:	13 97       	sbiw	r26, 0x03	; 3
     be8:	28 17       	cp	r18, r24
     bea:	39 07       	cpc	r19, r25
     bec:	21 f4       	brne	.+8      	; 0xbf6 <AFSK_adc_isr+0x1da>
    f->tail = f->begin;
     bee:	8d 91       	ld	r24, X+
     bf0:	9c 91       	ld	r25, X
     bf2:	11 97       	sbiw	r26, 0x01	; 1
     bf4:	05 c0       	rjmp	.+10     	; 0xc00 <AFSK_adc_isr+0x1e4>
  } else {
    f->tail++;
     bf6:	16 96       	adiw	r26, 0x06	; 6
     bf8:	8d 91       	ld	r24, X+
     bfa:	9c 91       	ld	r25, X
     bfc:	17 97       	sbiw	r26, 0x07	; 7
     bfe:	01 96       	adiw	r24, 0x01	; 1
     c00:	17 96       	adiw	r26, 0x07	; 7
     c02:	9c 93       	st	X, r25
     c04:	8e 93       	st	-X, r24
     c06:	16 97       	sbiw	r26, 0x06	; 6
            // If it isn't, we'll push the HDLC_FLAG into
            // the buffer and indicate that we are now
            // receiving data. For bling we also turn
            // on the RX LED.
            fifo_push(fifo, HDLC_FLAG);
            hdlc->receiving = true;
     c08:	81 e0       	ldi	r24, 0x01	; 1
     c0a:	81 8b       	std	Z+17, r24	; 0x11
            #if OPEN_SQUELCH == false
                LED_RX_ON();
     c0c:	2a 9a       	sbi	0x05, 2	; 5
     c0e:	b0 c0       	rjmp	.+352    	; 0xd70 <AFSK_adc_isr+0x354>
    // (or silence) is taking place, and the demodulator
    // returns an endless stream of zeroes. Due to the NRZ
    // coding, the actual bits send to this function will
    // be an endless stream of ones, which this AND operation
    // will also detect.
    if ((hdlc->demodulatedBits & HDLC_RESET) == HDLC_RESET) {
     c10:	98 2f       	mov	r25, r24
     c12:	9f 77       	andi	r25, 0x7F	; 127
     c14:	9f 37       	cpi	r25, 0x7F	; 127
     c16:	19 f4       	brne	.+6      	; 0xc1e <AFSK_adc_isr+0x202>
        // If we have, something probably went wrong at the
        // transmitting end, and we abort the reception.
        hdlc->receiving = false;
     c18:	11 8a       	std	Z+17, r1	; 0x11
        LED_RX_OFF();
     c1a:	2a 98       	cbi	0x05, 2	; 5
     c1c:	da c0       	rjmp	.+436    	; 0xdd2 <AFSK_adc_isr+0x3b6>
    }

    // If we have not yet seen a HDLC_FLAG indicating that
    // a transmission is actually taking place, don't bother
    // with anything.
    if (!hdlc->receiving)
     c1e:	91 89       	ldd	r25, Z+17	; 0x11
     c20:	99 23       	and	r25, r25
     c22:	09 f4       	brne	.+2      	; 0xc26 <AFSK_adc_isr+0x20a>
     c24:	d6 c0       	rjmp	.+428    	; 0xdd2 <AFSK_adc_isr+0x3b6>
    // 
    // We do the detection by applying an AND bit-mask to the
    // stream of demodulated bits. This mask is 00111111 (0x3f)
    // if the result of the operation is 00111110 (0x3e), we
    // have detected a stuffed bit.
    if ((hdlc->demodulatedBits & 0x3f) == 0x3e)
     c26:	98 2f       	mov	r25, r24
     c28:	9f 73       	andi	r25, 0x3F	; 63
     c2a:	9e 33       	cpi	r25, 0x3E	; 62
     c2c:	09 f4       	brne	.+2      	; 0xc30 <AFSK_adc_isr+0x214>
     c2e:	d1 c0       	rjmp	.+418    	; 0xdd2 <AFSK_adc_isr+0x3b6>
        return ret;

    // If we have an actual 1 bit, push this to the current byte
    // If it's a zero, we don't need to do anything, since the
    // bit is initialized to zero when we bitshifted earlier.
    if (hdlc->demodulatedBits & 0x01)
     c30:	80 ff       	sbrs	r24, 0
     c32:	03 c0       	rjmp	.+6      	; 0xc3a <AFSK_adc_isr+0x21e>
        hdlc->currentByte |= 0x80;
     c34:	80 89       	ldd	r24, Z+16	; 0x10
     c36:	80 68       	ori	r24, 0x80	; 128
     c38:	80 8b       	std	Z+16, r24	; 0x10

    // Increment the bitIndex and check if we have a complete byte
    if (++hdlc->bitIndex >= 8) {
     c3a:	97 85       	ldd	r25, Z+15	; 0x0f
     c3c:	9f 5f       	subi	r25, 0xFF	; 255
     c3e:	97 87       	std	Z+15, r25	; 0x0f
     c40:	80 89       	ldd	r24, Z+16	; 0x10
     c42:	98 30       	cpi	r25, 0x08	; 8
     c44:	08 f4       	brcc	.+2      	; 0xc48 <AFSK_adc_isr+0x22c>
     c46:	99 c0       	rjmp	.+306    	; 0xd7a <AFSK_adc_isr+0x35e>
     c48:	df 01       	movw	r26, r30
     c4a:	ab 58       	subi	r26, 0x8B	; 139
     c4c:	bf 4f       	sbci	r27, 0xFF	; 255
        // of a bitstuffed byte that is equal to said control
        // character, but is actually part of the data stream.
        // By inserting the escape character, we tell the protocol
        // layer that this is not an actual control character, but
        // data.
        if ((hdlc->currentByte == HDLC_FLAG ||
     c4e:	92 e8       	ldi	r25, 0x82	; 130
     c50:	98 0f       	add	r25, r24
     c52:	92 30       	cpi	r25, 0x02	; 2
     c54:	18 f0       	brcs	.+6      	; 0xc5c <AFSK_adc_isr+0x240>
             hdlc->currentByte == HDLC_RESET ||
     c56:	8b 31       	cpi	r24, 0x1B	; 27
     c58:	09 f0       	breq	.+2      	; 0xc5c <AFSK_adc_isr+0x240>
     c5a:	44 c0       	rjmp	.+136    	; 0xce4 <AFSK_adc_isr+0x2c8>
inline bool fifo_isempty(const FIFOBuffer *f) {
  return f->head == f->tail;
}

inline bool fifo_isfull(const FIFOBuffer *f) {
  return ((f->head == f->begin) && (f->tail == f->end)) || (f->tail == f->head - 1);
     c5c:	14 96       	adiw	r26, 0x04	; 4
     c5e:	2d 91       	ld	r18, X+
     c60:	3c 91       	ld	r19, X
     c62:	15 97       	sbiw	r26, 0x05	; 5
     c64:	8d 91       	ld	r24, X+
     c66:	9c 91       	ld	r25, X
     c68:	11 97       	sbiw	r26, 0x01	; 1
     c6a:	28 17       	cp	r18, r24
     c6c:	39 07       	cpc	r19, r25
     c6e:	59 f4       	brne	.+22     	; 0xc86 <AFSK_adc_isr+0x26a>
     c70:	16 96       	adiw	r26, 0x06	; 6
     c72:	2d 91       	ld	r18, X+
     c74:	3c 91       	ld	r19, X
     c76:	17 97       	sbiw	r26, 0x07	; 7
     c78:	12 96       	adiw	r26, 0x02	; 2
     c7a:	8d 91       	ld	r24, X+
     c7c:	9c 91       	ld	r25, X
     c7e:	13 97       	sbiw	r26, 0x03	; 3
     c80:	28 17       	cp	r18, r24
     c82:	39 07       	cpc	r19, r25
     c84:	59 f1       	breq	.+86     	; 0xcdc <AFSK_adc_isr+0x2c0>
     c86:	16 96       	adiw	r26, 0x06	; 6
     c88:	2d 91       	ld	r18, X+
     c8a:	3c 91       	ld	r19, X
     c8c:	17 97       	sbiw	r26, 0x07	; 7
     c8e:	14 96       	adiw	r26, 0x04	; 4
     c90:	8d 91       	ld	r24, X+
     c92:	9c 91       	ld	r25, X
     c94:	15 97       	sbiw	r26, 0x05	; 5
     c96:	01 97       	sbiw	r24, 0x01	; 1
             hdlc->currentByte == AX25_ESC)) {
            // We also need to check that our received data buffer
            // is not full before putting more data in
            if (!fifo_isfull(fifo)) {
     c98:	28 17       	cp	r18, r24
     c9a:	39 07       	cpc	r19, r25
     c9c:	f9 f0       	breq	.+62     	; 0xcdc <AFSK_adc_isr+0x2c0>
}

inline void fifo_push(FIFOBuffer *f, unsigned char c) {
  *(f->tail) = c;
     c9e:	16 96       	adiw	r26, 0x06	; 6
     ca0:	cd 91       	ld	r28, X+
     ca2:	dc 91       	ld	r29, X
     ca4:	17 97       	sbiw	r26, 0x07	; 7
     ca6:	8b e1       	ldi	r24, 0x1B	; 27
     ca8:	88 83       	st	Y, r24
  
  if (f->tail == f->end) {
     caa:	16 96       	adiw	r26, 0x06	; 6
     cac:	2d 91       	ld	r18, X+
     cae:	3c 91       	ld	r19, X
     cb0:	17 97       	sbiw	r26, 0x07	; 7
     cb2:	12 96       	adiw	r26, 0x02	; 2
     cb4:	8d 91       	ld	r24, X+
     cb6:	9c 91       	ld	r25, X
     cb8:	13 97       	sbiw	r26, 0x03	; 3
     cba:	28 17       	cp	r18, r24
     cbc:	39 07       	cpc	r19, r25
     cbe:	21 f4       	brne	.+8      	; 0xcc8 <AFSK_adc_isr+0x2ac>
    f->tail = f->begin;
     cc0:	8d 91       	ld	r24, X+
     cc2:	9c 91       	ld	r25, X
     cc4:	11 97       	sbiw	r26, 0x01	; 1
     cc6:	05 c0       	rjmp	.+10     	; 0xcd2 <AFSK_adc_isr+0x2b6>
  } else {
    f->tail++;
     cc8:	16 96       	adiw	r26, 0x06	; 6
     cca:	8d 91       	ld	r24, X+
     ccc:	9c 91       	ld	r25, X
     cce:	17 97       	sbiw	r26, 0x07	; 7
     cd0:	01 96       	adiw	r24, 0x01	; 1
     cd2:	17 96       	adiw	r26, 0x07	; 7
     cd4:	9c 93       	st	X, r25
     cd6:	8e 93       	st	-X, r24
     cd8:	16 97       	sbiw	r26, 0x06	; 6
     cda:	04 c0       	rjmp	.+8      	; 0xce4 <AFSK_adc_isr+0x2c8>
                fifo_push(fifo, AX25_ESC);
            } else {
                // If it is, abort and return false
                hdlc->receiving = false;
     cdc:	11 8a       	std	Z+17, r1	; 0x11
                LED_RX_OFF();
     cde:	2a 98       	cbi	0x05, 2	; 5
                ret = false;
     ce0:	80 e0       	ldi	r24, 0x00	; 0
     ce2:	01 c0       	rjmp	.+2      	; 0xce6 <AFSK_adc_isr+0x2ca>
}

static bool hdlcParse(Hdlc *hdlc, bool bit, FIFOBuffer *fifo) {
    // Initialise a return value. We start with the
    // assumption that all is going to end well :)
    bool ret = true;
     ce4:	81 e0       	ldi	r24, 0x01	; 1
inline bool fifo_isempty(const FIFOBuffer *f) {
  return f->head == f->tail;
}

inline bool fifo_isfull(const FIFOBuffer *f) {
  return ((f->head == f->begin) && (f->tail == f->end)) || (f->tail == f->head - 1);
     ce6:	14 96       	adiw	r26, 0x04	; 4
     ce8:	4d 91       	ld	r20, X+
     cea:	5c 91       	ld	r21, X
     cec:	15 97       	sbiw	r26, 0x05	; 5
     cee:	2d 91       	ld	r18, X+
     cf0:	3c 91       	ld	r19, X
     cf2:	11 97       	sbiw	r26, 0x01	; 1
     cf4:	42 17       	cp	r20, r18
     cf6:	53 07       	cpc	r21, r19
     cf8:	59 f4       	brne	.+22     	; 0xd10 <AFSK_adc_isr+0x2f4>
     cfa:	16 96       	adiw	r26, 0x06	; 6
     cfc:	4d 91       	ld	r20, X+
     cfe:	5c 91       	ld	r21, X
     d00:	17 97       	sbiw	r26, 0x07	; 7
     d02:	12 96       	adiw	r26, 0x02	; 2
     d04:	2d 91       	ld	r18, X+
     d06:	3c 91       	ld	r19, X
     d08:	13 97       	sbiw	r26, 0x03	; 3
     d0a:	42 17       	cp	r20, r18
     d0c:	53 07       	cpc	r21, r19
     d0e:	69 f1       	breq	.+90     	; 0xd6a <AFSK_adc_isr+0x34e>
     d10:	16 96       	adiw	r26, 0x06	; 6
     d12:	4d 91       	ld	r20, X+
     d14:	5c 91       	ld	r21, X
     d16:	17 97       	sbiw	r26, 0x07	; 7
     d18:	14 96       	adiw	r26, 0x04	; 4
     d1a:	2d 91       	ld	r18, X+
     d1c:	3c 91       	ld	r19, X
     d1e:	15 97       	sbiw	r26, 0x05	; 5
     d20:	21 50       	subi	r18, 0x01	; 1
     d22:	31 09       	sbc	r19, r1
            }
        }

        // Push the actual byte to the received data FIFO,
        // if it isn't full.
        if (!fifo_isfull(fifo)) {
     d24:	42 17       	cp	r20, r18
     d26:	53 07       	cpc	r21, r19
     d28:	01 f1       	breq	.+64     	; 0xd6a <AFSK_adc_isr+0x34e>
            fifo_push(fifo, hdlc->currentByte);
     d2a:	90 89       	ldd	r25, Z+16	; 0x10
}

inline void fifo_push(FIFOBuffer *f, unsigned char c) {
  *(f->tail) = c;
     d2c:	16 96       	adiw	r26, 0x06	; 6
     d2e:	cd 91       	ld	r28, X+
     d30:	dc 91       	ld	r29, X
     d32:	17 97       	sbiw	r26, 0x07	; 7
     d34:	98 83       	st	Y, r25
  
  if (f->tail == f->end) {
     d36:	16 96       	adiw	r26, 0x06	; 6
     d38:	4d 91       	ld	r20, X+
     d3a:	5c 91       	ld	r21, X
     d3c:	17 97       	sbiw	r26, 0x07	; 7
     d3e:	12 96       	adiw	r26, 0x02	; 2
     d40:	2d 91       	ld	r18, X+
     d42:	3c 91       	ld	r19, X
     d44:	13 97       	sbiw	r26, 0x03	; 3
     d46:	42 17       	cp	r20, r18
     d48:	53 07       	cpc	r21, r19
     d4a:	21 f4       	brne	.+8      	; 0xd54 <AFSK_adc_isr+0x338>
    f->tail = f->begin;
     d4c:	2d 91       	ld	r18, X+
     d4e:	3c 91       	ld	r19, X
     d50:	11 97       	sbiw	r26, 0x01	; 1
     d52:	06 c0       	rjmp	.+12     	; 0xd60 <AFSK_adc_isr+0x344>
  } else {
    f->tail++;
     d54:	16 96       	adiw	r26, 0x06	; 6
     d56:	2d 91       	ld	r18, X+
     d58:	3c 91       	ld	r19, X
     d5a:	17 97       	sbiw	r26, 0x07	; 7
     d5c:	2f 5f       	subi	r18, 0xFF	; 255
     d5e:	3f 4f       	sbci	r19, 0xFF	; 255
     d60:	17 96       	adiw	r26, 0x07	; 7
     d62:	3c 93       	st	X, r19
     d64:	2e 93       	st	-X, r18
     d66:	16 97       	sbiw	r26, 0x06	; 6
     d68:	03 c0       	rjmp	.+6      	; 0xd70 <AFSK_adc_isr+0x354>
        } else {
            // If it is, well, you know by now!
            hdlc->receiving = false;
     d6a:	11 8a       	std	Z+17, r1	; 0x11
            LED_RX_OFF();
     d6c:	2a 98       	cbi	0x05, 2	; 5
            ret = false;
     d6e:	80 e0       	ldi	r24, 0x00	; 0
        }

        // Wipe received byte and reset bit index to 0
        hdlc->currentByte = 0;
     d70:	10 8a       	std	Z+16, r1	; 0x10
        hdlc->bitIndex = 0;
     d72:	17 86       	std	Z+15, r1	; 0x0f
        // that we can use to synchronize our phase.
        //
        // We also check the return of the Link Control parser
        // to check if an error occured.

        if (!hdlcParse(&afsk->hdlc, !TRANSITION_FOUND(afsk->actualBits), &afsk->rxFifo)) {
     d74:	88 23       	and	r24, r24
     d76:	21 f0       	breq	.+8      	; 0xd80 <AFSK_adc_isr+0x364>
     d78:	2c c0       	rjmp	.+88     	; 0xdd2 <AFSK_adc_isr+0x3b6>
        hdlc->bitIndex = 0;

    } else {
        // We don't have a full byte yet, bitshift the byte
        // to make room for the next bit
        hdlc->currentByte >>= 1;
     d7a:	86 95       	lsr	r24
     d7c:	80 8b       	std	Z+16, r24	; 0x10
     d7e:	29 c0       	rjmp	.+82     	; 0xdd2 <AFSK_adc_isr+0x3b6>
        //
        // We also check the return of the Link Control parser
        // to check if an error occured.

        if (!hdlcParse(&afsk->hdlc, !TRANSITION_FOUND(afsk->actualBits), &afsk->rxFifo)) {
            afsk->status |= 1;
     d80:	df 01       	movw	r26, r30
     d82:	a8 53       	subi	r26, 0x38	; 56
     d84:	bf 4f       	sbci	r27, 0xFF	; 255
     d86:	8d 91       	ld	r24, X+
     d88:	9c 91       	ld	r25, X
     d8a:	11 97       	sbiw	r26, 0x01	; 1
     d8c:	81 60       	ori	r24, 0x01	; 1
     d8e:	11 96       	adiw	r26, 0x01	; 1
     d90:	9c 93       	st	X, r25
     d92:	8e 93       	st	-X, r24
inline bool fifo_isempty(const FIFOBuffer *f) {
  return f->head == f->tail;
}

inline bool fifo_isfull(const FIFOBuffer *f) {
  return ((f->head == f->begin) && (f->tail == f->end)) || (f->tail == f->head - 1);
     d94:	eb 58       	subi	r30, 0x8B	; 139
     d96:	ff 4f       	sbci	r31, 0xFF	; 255
     d98:	24 81       	ldd	r18, Z+4	; 0x04
     d9a:	35 81       	ldd	r19, Z+5	; 0x05
     d9c:	80 81       	ld	r24, Z
     d9e:	91 81       	ldd	r25, Z+1	; 0x01
     da0:	28 17       	cp	r18, r24
     da2:	39 07       	cpc	r19, r25
     da4:	39 f4       	brne	.+14     	; 0xdb4 <AFSK_adc_isr+0x398>
     da6:	26 81       	ldd	r18, Z+6	; 0x06
     da8:	37 81       	ldd	r19, Z+7	; 0x07
     daa:	82 81       	ldd	r24, Z+2	; 0x02
     dac:	93 81       	ldd	r25, Z+3	; 0x03
     dae:	28 17       	cp	r18, r24
     db0:	39 07       	cpc	r19, r25
     db2:	41 f0       	breq	.+16     	; 0xdc4 <AFSK_adc_isr+0x3a8>
     db4:	26 81       	ldd	r18, Z+6	; 0x06
     db6:	37 81       	ldd	r19, Z+7	; 0x07
     db8:	84 81       	ldd	r24, Z+4	; 0x04
     dba:	95 81       	ldd	r25, Z+5	; 0x05
     dbc:	01 97       	sbiw	r24, 0x01	; 1
            if (fifo_isfull(&afsk->rxFifo)) {
     dbe:	28 17       	cp	r18, r24
     dc0:	39 07       	cpc	r19, r25
     dc2:	39 f4       	brne	.+14     	; 0xdd2 <AFSK_adc_isr+0x3b6>
    return *(f->head++);
  }
}

inline void fifo_flush(FIFOBuffer *f) {
  f->head = f->tail;
     dc4:	86 81       	ldd	r24, Z+6	; 0x06
     dc6:	97 81       	ldd	r25, Z+7	; 0x07
     dc8:	95 83       	std	Z+5, r25	; 0x05
     dca:	84 83       	std	Z+4, r24	; 0x04
                fifo_flush(&afsk->rxFifo);
                afsk->status = 0;
     dcc:	11 96       	adiw	r26, 0x01	; 1
     dce:	1c 92       	st	X, r1
     dd0:	1e 92       	st	-X, r1
            }
        }
    }

}
     dd2:	df 91       	pop	r29
     dd4:	cf 91       	pop	r28
     dd6:	1f 91       	pop	r17
     dd8:	0f 91       	pop	r16
     dda:	ff 90       	pop	r15
     ddc:	ef 90       	pop	r14
     dde:	08 95       	ret

00000de0 <__vector_21>:


ISR(ADC_vect) {
     de0:	1f 92       	push	r1
     de2:	0f 92       	push	r0
     de4:	0f b6       	in	r0, 0x3f	; 63
     de6:	0f 92       	push	r0
     de8:	11 24       	eor	r1, r1
     dea:	2f 93       	push	r18
     dec:	3f 93       	push	r19
     dee:	4f 93       	push	r20
     df0:	5f 93       	push	r21
     df2:	6f 93       	push	r22
     df4:	7f 93       	push	r23
     df6:	8f 93       	push	r24
     df8:	9f 93       	push	r25
     dfa:	af 93       	push	r26
     dfc:	bf 93       	push	r27
     dfe:	ef 93       	push	r30
     e00:	ff 93       	push	r31
    TIFR1 = _BV(ICF1);
     e02:	80 e2       	ldi	r24, 0x20	; 32
     e04:	86 bb       	out	0x16, r24	; 22
    AFSK_adc_isr(AFSK_modem, ((int16_t)((ADC) >> 2) - 128));
     e06:	60 91 78 00 	lds	r22, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7e0078>
     e0a:	70 91 79 00 	lds	r23, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7e0079>
     e0e:	76 95       	lsr	r23
     e10:	67 95       	ror	r22
     e12:	76 95       	lsr	r23
     e14:	67 95       	ror	r22
     e16:	60 58       	subi	r22, 0x80	; 128
     e18:	80 91 60 08 	lds	r24, 0x0860	; 0x800860 <AFSK_modem>
     e1c:	90 91 61 08 	lds	r25, 0x0861	; 0x800861 <AFSK_modem+0x1>
     e20:	0e 94 0e 05 	call	0xa1c	; 0xa1c <AFSK_adc_isr>
    if (hw_afsk_dac_isr) {
     e24:	80 91 19 01 	lds	r24, 0x0119	; 0x800119 <hw_afsk_dac_isr>
     e28:	88 23       	and	r24, r24
     e2a:	41 f0       	breq	.+16     	; 0xe3c <__vector_21+0x5c>
        DAC_PORT = (AFSK_dac_isr(AFSK_modem) & 0xF0); 
     e2c:	80 91 60 08 	lds	r24, 0x0860	; 0x800860 <AFSK_modem>
     e30:	90 91 61 08 	lds	r25, 0x0861	; 0x800861 <AFSK_modem+0x1>
     e34:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <AFSK_dac_isr>
     e38:	80 7f       	andi	r24, 0xF0	; 240
     e3a:	01 c0       	rjmp	.+2      	; 0xe3e <__vector_21+0x5e>
    } else {
        DAC_PORT = 0x88;
     e3c:	88 e8       	ldi	r24, 0x88	; 136
     e3e:	8b b9       	out	0x0b, r24	; 11
    }
    ++_clock;
     e40:	80 91 2a 05 	lds	r24, 0x052A	; 0x80052a <_clock>
     e44:	90 91 2b 05 	lds	r25, 0x052B	; 0x80052b <_clock+0x1>
     e48:	a0 91 2c 05 	lds	r26, 0x052C	; 0x80052c <_clock+0x2>
     e4c:	b0 91 2d 05 	lds	r27, 0x052D	; 0x80052d <_clock+0x3>
     e50:	01 96       	adiw	r24, 0x01	; 1
     e52:	a1 1d       	adc	r26, r1
     e54:	b1 1d       	adc	r27, r1
     e56:	80 93 2a 05 	sts	0x052A, r24	; 0x80052a <_clock>
     e5a:	90 93 2b 05 	sts	0x052B, r25	; 0x80052b <_clock+0x1>
     e5e:	a0 93 2c 05 	sts	0x052C, r26	; 0x80052c <_clock+0x2>
     e62:	b0 93 2d 05 	sts	0x052D, r27	; 0x80052d <_clock+0x3>
}
     e66:	ff 91       	pop	r31
     e68:	ef 91       	pop	r30
     e6a:	bf 91       	pop	r27
     e6c:	af 91       	pop	r26
     e6e:	9f 91       	pop	r25
     e70:	8f 91       	pop	r24
     e72:	7f 91       	pop	r23
     e74:	6f 91       	pop	r22
     e76:	5f 91       	pop	r21
     e78:	4f 91       	pop	r20
     e7a:	3f 91       	pop	r19
     e7c:	2f 91       	pop	r18
     e7e:	0f 90       	pop	r0
     e80:	0f be       	out	0x3f, r0	; 63
     e82:	0f 90       	pop	r0
     e84:	1f 90       	pop	r1
     e86:	18 95       	reti

00000e88 <ax25_putchar>:
        ctx->escape = false;
    }
}

static void ax25_putchar(AX25Ctx *ctx, uint8_t c)
{
     e88:	cf 92       	push	r12
     e8a:	df 92       	push	r13
     e8c:	ef 92       	push	r14
     e8e:	ff 92       	push	r15
     e90:	0f 93       	push	r16
     e92:	1f 93       	push	r17
     e94:	cf 93       	push	r28
     e96:	df 93       	push	r29
     e98:	1f 92       	push	r1
     e9a:	cd b7       	in	r28, 0x3d	; 61
     e9c:	de b7       	in	r29, 0x3e	; 62
     e9e:	7c 01       	movw	r14, r24
     ea0:	26 2f       	mov	r18, r22
    if (c == HDLC_FLAG || c == HDLC_RESET || c == AX25_ESC) fputc(AX25_ESC, ctx->ch);
     ea2:	82 e8       	ldi	r24, 0x82	; 130
     ea4:	86 0f       	add	r24, r22
     ea6:	87 01       	movw	r16, r14
     ea8:	08 5e       	subi	r16, 0xE8	; 232
     eaa:	1c 4f       	sbci	r17, 0xFC	; 252
     eac:	82 30       	cpi	r24, 0x02	; 2
     eae:	10 f0       	brcs	.+4      	; 0xeb4 <ax25_putchar+0x2c>
     eb0:	6b 31       	cpi	r22, 0x1B	; 27
     eb2:	49 f4       	brne	.+18     	; 0xec6 <ax25_putchar+0x3e>
     eb4:	f8 01       	movw	r30, r16
     eb6:	60 81       	ld	r22, Z
     eb8:	71 81       	ldd	r23, Z+1	; 0x01
     eba:	8b e1       	ldi	r24, 0x1B	; 27
     ebc:	90 e0       	ldi	r25, 0x00	; 0
     ebe:	29 83       	std	Y+1, r18	; 0x01
     ec0:	0e 94 1a 0c 	call	0x1834	; 0x1834 <fputc>
     ec4:	29 81       	ldd	r18, Y+1	; 0x01
    ctx->crc_out = update_crc_ccit(c, ctx->crc_out);
     ec6:	d7 01       	movw	r26, r14
     ec8:	a2 5e       	subi	r26, 0xE2	; 226
     eca:	bc 4f       	sbci	r27, 0xFC	; 252
     ecc:	3c 91       	ld	r19, X
     ece:	11 96       	adiw	r26, 0x01	; 1
     ed0:	4c 91       	ld	r20, X
     ed2:	11 97       	sbiw	r26, 0x01	; 1
#define CRC_CCIT_INIT_VAL ((uint16_t)0xFFFF)

extern const uint16_t crc_ccit_table[256];

inline uint16_t update_crc_ccit(uint8_t c, uint16_t prev_crc) {
    return (prev_crc >> 8) ^ pgm_read_word(&crc_ccit_table[(prev_crc ^ c) & 0xff]);
     ed4:	82 2f       	mov	r24, r18
     ed6:	90 e0       	ldi	r25, 0x00	; 0
     ed8:	fc 01       	movw	r30, r24
     eda:	e3 27       	eor	r30, r19
     edc:	ee 0f       	add	r30, r30
     ede:	ff 1f       	adc	r31, r31
     ee0:	e3 59       	subi	r30, 0x93	; 147
     ee2:	fe 4f       	sbci	r31, 0xFE	; 254
     ee4:	25 91       	lpm	r18, Z+
     ee6:	34 91       	lpm	r19, Z
     ee8:	c4 2e       	mov	r12, r20
     eea:	d1 2c       	mov	r13, r1
     eec:	2c 25       	eor	r18, r12
     eee:	3d 25       	eor	r19, r13
     ef0:	2d 93       	st	X+, r18
     ef2:	3c 93       	st	X, r19
    fputc(c, ctx->ch);
     ef4:	f8 01       	movw	r30, r16
     ef6:	60 81       	ld	r22, Z
     ef8:	71 81       	ldd	r23, Z+1	; 0x01
}
     efa:	0f 90       	pop	r0
     efc:	df 91       	pop	r29
     efe:	cf 91       	pop	r28
     f00:	1f 91       	pop	r17
     f02:	0f 91       	pop	r16
     f04:	ff 90       	pop	r15
     f06:	ef 90       	pop	r14
     f08:	df 90       	pop	r13
     f0a:	cf 90       	pop	r12

static void ax25_putchar(AX25Ctx *ctx, uint8_t c)
{
    if (c == HDLC_FLAG || c == HDLC_RESET || c == AX25_ESC) fputc(AX25_ESC, ctx->ch);
    ctx->crc_out = update_crc_ccit(c, ctx->crc_out);
    fputc(c, ctx->ch);
     f0c:	0c 94 1a 0c 	jmp	0x1834	; 0x1834 <fputc>

00000f10 <ax25_init>:
#define MIN(a,b) ({ typeof(a) _a = (a); typeof(b) _b = (b); ((typeof(_a))((_a < _b) ? _a : _b)); })
#define DECODE_CALL(buf, addr) for (unsigned i = 0; i < sizeof((addr)); i++) { char c = (*(buf)++ >> 1); (addr)[i] = (c == ' ') ? '\x0' : c; }
#define AX25_SET_REPEATED(msg, idx, val) do { if (val) { (msg)->rpt_flags |= _BV(idx); } else { (msg)->rpt_flags &= ~_BV(idx) ; } } while(0)

void ax25_init(AX25Ctx *ctx, FILE *channel, ax25_callback_t hook) {
    memset(ctx, 0, sizeof(*ctx));
     f10:	24 e2       	ldi	r18, 0x24	; 36
     f12:	33 e0       	ldi	r19, 0x03	; 3
     f14:	dc 01       	movw	r26, r24
     f16:	f9 01       	movw	r30, r18
     f18:	1d 92       	st	X+, r1
     f1a:	31 97       	sbiw	r30, 0x01	; 1
     f1c:	e9 f7       	brne	.-6      	; 0xf18 <ax25_init+0x8>
    ctx->ch = channel;
     f1e:	fc 01       	movw	r30, r24
     f20:	e8 5e       	subi	r30, 0xE8	; 232
     f22:	fc 4f       	sbci	r31, 0xFC	; 252
     f24:	71 83       	std	Z+1, r23	; 0x01
     f26:	60 83       	st	Z, r22
    ctx->hook = hook;
     f28:	38 96       	adiw	r30, 0x08	; 8
     f2a:	51 83       	std	Z+1, r21	; 0x01
     f2c:	40 83       	st	Z, r20
    ctx->crc_in = ctx->crc_out = CRC_CCIT_INIT_VAL;
     f2e:	32 97       	sbiw	r30, 0x02	; 2
     f30:	2f ef       	ldi	r18, 0xFF	; 255
     f32:	3f ef       	ldi	r19, 0xFF	; 255
     f34:	31 83       	std	Z+1, r19	; 0x01
     f36:	20 83       	st	Z, r18
     f38:	32 97       	sbiw	r30, 0x02	; 2
     f3a:	31 83       	std	Z+1, r19	; 0x01
     f3c:	20 83       	st	Z, r18
     f3e:	08 95       	ret

00000f40 <ax25_poll>:
        if (ctx->hook) ctx->hook(&msg);        

    #endif
}

void ax25_poll(AX25Ctx *ctx) {
     f40:	3f 92       	push	r3
     f42:	4f 92       	push	r4
     f44:	5f 92       	push	r5
     f46:	6f 92       	push	r6
     f48:	7f 92       	push	r7
     f4a:	8f 92       	push	r8
     f4c:	9f 92       	push	r9
     f4e:	af 92       	push	r10
     f50:	bf 92       	push	r11
     f52:	cf 92       	push	r12
     f54:	df 92       	push	r13
     f56:	ef 92       	push	r14
     f58:	ff 92       	push	r15
     f5a:	0f 93       	push	r16
     f5c:	1f 93       	push	r17
     f5e:	cf 93       	push	r28
     f60:	df 93       	push	r29
     f62:	2c 01       	movw	r4, r24
    int c;
    
    while ((c = fgetc(ctx->ch)) != EOF) {
     f64:	3c 01       	movw	r6, r24
     f66:	28 ee       	ldi	r18, 0xE8	; 232
     f68:	62 1a       	sub	r6, r18
     f6a:	2c ef       	ldi	r18, 0xFC	; 252
     f6c:	72 0a       	sbc	r7, r18
        if (!ctx->escape && c == HDLC_FLAG) {
     f6e:	6c 01       	movw	r12, r24
     f70:	4d ed       	ldi	r20, 0xDD	; 221
     f72:	c4 1a       	sub	r12, r20
     f74:	4c ef       	ldi	r20, 0xFC	; 252
     f76:	d4 0a       	sbc	r13, r20
        if (!ctx->escape && c == AX25_ESC) {
            ctx->escape = true;
            continue;
        }

        if (ctx->sync) {
     f78:	ec 01       	movw	r28, r24
     f7a:	ce 5d       	subi	r28, 0xDE	; 222
     f7c:	dc 4f       	sbci	r29, 0xFC	; 252
            if (ctx->frame_len < AX25_MAX_FRAME_LEN) {
     f7e:	8c 01       	movw	r16, r24
     f80:	06 5e       	subi	r16, 0xE6	; 230
     f82:	1c 4f       	sbci	r17, 0xFC	; 252
                ctx->buf[ctx->frame_len++] = c;
                ctx->crc_in = update_crc_ccit(c, ctx->crc_in);
     f84:	7c 01       	movw	r14, r24
     f86:	84 ee       	ldi	r24, 0xE4	; 228
     f88:	e8 1a       	sub	r14, r24
     f8a:	8c ef       	ldi	r24, 0xFC	; 252
     f8c:	f8 0a       	sbc	r15, r24
            ctx->sync = false;
            continue;
        }

        if (!ctx->escape && c == AX25_ESC) {
            ctx->escape = true;
     f8e:	33 24       	eor	r3, r3
     f90:	33 94       	inc	r3
                    #endif
                    ax25_decode(ctx);
                }
            }
            ctx->sync = true;
            ctx->crc_in = CRC_CCIT_INIT_VAL;
     f92:	aa 24       	eor	r10, r10
     f94:	aa 94       	dec	r10
     f96:	ba 2c       	mov	r11, r10
    ctx->crc_in = ctx->crc_out = CRC_CCIT_INIT_VAL;
}

static void ax25_decode(AX25Ctx *ctx) {
    #if SERIAL_PROTOCOL == PROTOCOL_KISS
        if (ctx->hook) ctx->hook(ctx);
     f98:	42 01       	movw	r8, r4
     f9a:	a0 ee       	ldi	r26, 0xE0	; 224
     f9c:	8a 1a       	sub	r8, r26
     f9e:	ac ef       	ldi	r26, 0xFC	; 252
     fa0:	9a 0a       	sbc	r9, r26
}

void ax25_poll(AX25Ctx *ctx) {
    int c;
    
    while ((c = fgetc(ctx->ch)) != EOF) {
     fa2:	f3 01       	movw	r30, r6
     fa4:	80 81       	ld	r24, Z
     fa6:	91 81       	ldd	r25, Z+1	; 0x01
     fa8:	0e 94 dc 0b 	call	0x17b8	; 0x17b8 <fgetc>
     fac:	8f 3f       	cpi	r24, 0xFF	; 255
     fae:	ff ef       	ldi	r31, 0xFF	; 255
     fb0:	9f 07       	cpc	r25, r31
     fb2:	09 f4       	brne	.+2      	; 0xfb6 <ax25_poll+0x76>
     fb4:	58 c0       	rjmp	.+176    	; 0x1066 <ax25_poll+0x126>
        if (!ctx->escape && c == HDLC_FLAG) {
     fb6:	f6 01       	movw	r30, r12
     fb8:	20 81       	ld	r18, Z
     fba:	21 11       	cpse	r18, r1
     fbc:	28 c0       	rjmp	.+80     	; 0x100e <ax25_poll+0xce>
     fbe:	8e 37       	cpi	r24, 0x7E	; 126
     fc0:	91 05       	cpc	r25, r1
     fc2:	d1 f4       	brne	.+52     	; 0xff8 <ax25_poll+0xb8>
            if (ctx->frame_len >= AX25_MIN_FRAME_LEN) {
     fc4:	d8 01       	movw	r26, r16
     fc6:	8d 91       	ld	r24, X+
     fc8:	9c 91       	ld	r25, X
     fca:	42 97       	sbiw	r24, 0x12	; 18
     fcc:	68 f0       	brcs	.+26     	; 0xfe8 <ax25_poll+0xa8>
                if (ctx->crc_in == AX25_CRC_CORRECT) {
     fce:	f7 01       	movw	r30, r14
     fd0:	80 81       	ld	r24, Z
     fd2:	91 81       	ldd	r25, Z+1	; 0x01
     fd4:	88 3b       	cpi	r24, 0xB8	; 184
     fd6:	90 4f       	sbci	r25, 0xF0	; 240
     fd8:	39 f4       	brne	.+14     	; 0xfe8 <ax25_poll+0xa8>
    ctx->crc_in = ctx->crc_out = CRC_CCIT_INIT_VAL;
}

static void ax25_decode(AX25Ctx *ctx) {
    #if SERIAL_PROTOCOL == PROTOCOL_KISS
        if (ctx->hook) ctx->hook(ctx);
     fda:	d4 01       	movw	r26, r8
     fdc:	ed 91       	ld	r30, X+
     fde:	fc 91       	ld	r31, X
     fe0:	30 97       	sbiw	r30, 0x00	; 0
     fe2:	11 f0       	breq	.+4      	; 0xfe8 <ax25_poll+0xa8>
     fe4:	c2 01       	movw	r24, r4
     fe6:	09 95       	icall
                        LED_RX_ON();
                    #endif
                    ax25_decode(ctx);
                }
            }
            ctx->sync = true;
     fe8:	38 82       	st	Y, r3
            ctx->crc_in = CRC_CCIT_INIT_VAL;
     fea:	f7 01       	movw	r30, r14
     fec:	b1 82       	std	Z+1, r11	; 0x01
     fee:	a0 82       	st	Z, r10
            ctx->frame_len = 0;
     ff0:	d8 01       	movw	r26, r16
     ff2:	1d 92       	st	X+, r1
     ff4:	1c 92       	st	X, r1
            continue;
     ff6:	d5 cf       	rjmp	.-86     	; 0xfa2 <ax25_poll+0x62>
        }

        if (!ctx->escape && c == HDLC_RESET) {
     ff8:	8f 37       	cpi	r24, 0x7F	; 127
     ffa:	91 05       	cpc	r25, r1
     ffc:	11 f4       	brne	.+4      	; 0x1002 <ax25_poll+0xc2>
            ctx->sync = false;
     ffe:	18 82       	st	Y, r1
            continue;
    1000:	d0 cf       	rjmp	.-96     	; 0xfa2 <ax25_poll+0x62>
        }

        if (!ctx->escape && c == AX25_ESC) {
    1002:	8b 31       	cpi	r24, 0x1B	; 27
    1004:	91 05       	cpc	r25, r1
    1006:	19 f4       	brne	.+6      	; 0x100e <ax25_poll+0xce>
            ctx->escape = true;
    1008:	f6 01       	movw	r30, r12
    100a:	30 82       	st	Z, r3
            continue;
    100c:	ca cf       	rjmp	.-108    	; 0xfa2 <ax25_poll+0x62>
        }

        if (ctx->sync) {
    100e:	28 81       	ld	r18, Y
    1010:	22 23       	and	r18, r18
    1012:	31 f1       	breq	.+76     	; 0x1060 <ax25_poll+0x120>
            if (ctx->frame_len < AX25_MAX_FRAME_LEN) {
    1014:	d8 01       	movw	r26, r16
    1016:	2d 91       	ld	r18, X+
    1018:	3c 91       	ld	r19, X
    101a:	28 31       	cpi	r18, 0x18	; 24
    101c:	b3 e0       	ldi	r27, 0x03	; 3
    101e:	3b 07       	cpc	r19, r27
    1020:	f0 f4       	brcc	.+60     	; 0x105e <ax25_poll+0x11e>
                ctx->buf[ctx->frame_len++] = c;
    1022:	a9 01       	movw	r20, r18
    1024:	4f 5f       	subi	r20, 0xFF	; 255
    1026:	5f 4f       	sbci	r21, 0xFF	; 255
    1028:	f8 01       	movw	r30, r16
    102a:	51 83       	std	Z+1, r21	; 0x01
    102c:	40 83       	st	Z, r20
    102e:	f2 01       	movw	r30, r4
    1030:	e2 0f       	add	r30, r18
    1032:	f3 1f       	adc	r31, r19
    1034:	80 83       	st	Z, r24
                ctx->crc_in = update_crc_ccit(c, ctx->crc_in);
    1036:	d7 01       	movw	r26, r14
    1038:	2d 91       	ld	r18, X+
    103a:	3c 91       	ld	r19, X
    103c:	f9 01       	movw	r30, r18
    103e:	e8 27       	eor	r30, r24
    1040:	ff 27       	eor	r31, r31
    1042:	ee 0f       	add	r30, r30
    1044:	ff 1f       	adc	r31, r31
    1046:	e3 59       	subi	r30, 0x93	; 147
    1048:	fe 4f       	sbci	r31, 0xFE	; 254
    104a:	85 91       	lpm	r24, Z+
    104c:	94 91       	lpm	r25, Z
    104e:	23 2f       	mov	r18, r19
    1050:	33 27       	eor	r19, r19
    1052:	82 27       	eor	r24, r18
    1054:	93 27       	eor	r25, r19
    1056:	f7 01       	movw	r30, r14
    1058:	91 83       	std	Z+1, r25	; 0x01
    105a:	80 83       	st	Z, r24
    105c:	01 c0       	rjmp	.+2      	; 0x1060 <ax25_poll+0x120>
            } else {
                ctx->sync = false;
    105e:	18 82       	st	Y, r1
            }
        }
        ctx->escape = false;
    1060:	d6 01       	movw	r26, r12
    1062:	1c 92       	st	X, r1
    1064:	9e cf       	rjmp	.-196    	; 0xfa2 <ax25_poll+0x62>
    }
}
    1066:	df 91       	pop	r29
    1068:	cf 91       	pop	r28
    106a:	1f 91       	pop	r17
    106c:	0f 91       	pop	r16
    106e:	ff 90       	pop	r15
    1070:	ef 90       	pop	r14
    1072:	df 90       	pop	r13
    1074:	cf 90       	pop	r12
    1076:	bf 90       	pop	r11
    1078:	af 90       	pop	r10
    107a:	9f 90       	pop	r9
    107c:	8f 90       	pop	r8
    107e:	7f 90       	pop	r7
    1080:	6f 90       	pop	r6
    1082:	5f 90       	pop	r5
    1084:	4f 90       	pop	r4
    1086:	3f 90       	pop	r3
    1088:	08 95       	ret

0000108a <ax25_sendRaw>:
    if (c == HDLC_FLAG || c == HDLC_RESET || c == AX25_ESC) fputc(AX25_ESC, ctx->ch);
    ctx->crc_out = update_crc_ccit(c, ctx->crc_out);
    fputc(c, ctx->ch);
}

void ax25_sendRaw(AX25Ctx *ctx, void *_buf, size_t len) {
    108a:	8f 92       	push	r8
    108c:	9f 92       	push	r9
    108e:	af 92       	push	r10
    1090:	bf 92       	push	r11
    1092:	cf 92       	push	r12
    1094:	df 92       	push	r13
    1096:	ef 92       	push	r14
    1098:	ff 92       	push	r15
    109a:	0f 93       	push	r16
    109c:	1f 93       	push	r17
    109e:	cf 93       	push	r28
    10a0:	df 93       	push	r29
    10a2:	8c 01       	movw	r16, r24
    10a4:	4b 01       	movw	r8, r22
    10a6:	5a 01       	movw	r10, r20
    ctx->crc_out = CRC_CCIT_INIT_VAL;
    10a8:	6c 01       	movw	r12, r24
    10aa:	82 ee       	ldi	r24, 0xE2	; 226
    10ac:	c8 1a       	sub	r12, r24
    10ae:	8c ef       	ldi	r24, 0xFC	; 252
    10b0:	d8 0a       	sbc	r13, r24
    10b2:	8f ef       	ldi	r24, 0xFF	; 255
    10b4:	9f ef       	ldi	r25, 0xFF	; 255
    10b6:	f6 01       	movw	r30, r12
    10b8:	91 83       	std	Z+1, r25	; 0x01
    10ba:	80 83       	st	Z, r24
    fputc(HDLC_FLAG, ctx->ch);
    10bc:	78 01       	movw	r14, r16
    10be:	f8 ee       	ldi	r31, 0xE8	; 232
    10c0:	ef 1a       	sub	r14, r31
    10c2:	fc ef       	ldi	r31, 0xFC	; 252
    10c4:	ff 0a       	sbc	r15, r31
    10c6:	f7 01       	movw	r30, r14
    10c8:	60 81       	ld	r22, Z
    10ca:	71 81       	ldd	r23, Z+1	; 0x01
    10cc:	8e e7       	ldi	r24, 0x7E	; 126
    10ce:	90 e0       	ldi	r25, 0x00	; 0
    10d0:	0e 94 1a 0c 	call	0x1834	; 0x1834 <fputc>
    10d4:	e4 01       	movw	r28, r8
    10d6:	a8 0c       	add	r10, r8
    10d8:	b9 1c       	adc	r11, r9
    const uint8_t *buf = (const uint8_t *)_buf;
    while (len--) ax25_putchar(ctx, *buf++);
    10da:	ca 15       	cp	r28, r10
    10dc:	db 05       	cpc	r29, r11
    10de:	29 f0       	breq	.+10     	; 0x10ea <ax25_sendRaw+0x60>
    10e0:	69 91       	ld	r22, Y+
    10e2:	c8 01       	movw	r24, r16
    10e4:	0e 94 44 07 	call	0xe88	; 0xe88 <ax25_putchar>
    10e8:	f8 cf       	rjmp	.-16     	; 0x10da <ax25_sendRaw+0x50>

    uint8_t crcl = (ctx->crc_out & 0xff) ^ 0xff;
    10ea:	f6 01       	movw	r30, r12
    10ec:	60 81       	ld	r22, Z
    10ee:	c1 81       	ldd	r28, Z+1	; 0x01
    10f0:	60 95       	com	r22
    uint8_t crch = (ctx->crc_out >> 8) ^ 0xff;
    ax25_putchar(ctx, crcl);
    10f2:	c8 01       	movw	r24, r16
    10f4:	0e 94 44 07 	call	0xe88	; 0xe88 <ax25_putchar>
    fputc(HDLC_FLAG, ctx->ch);
    const uint8_t *buf = (const uint8_t *)_buf;
    while (len--) ax25_putchar(ctx, *buf++);

    uint8_t crcl = (ctx->crc_out & 0xff) ^ 0xff;
    uint8_t crch = (ctx->crc_out >> 8) ^ 0xff;
    10f8:	6c 2f       	mov	r22, r28
    10fa:	60 95       	com	r22
    ax25_putchar(ctx, crcl);
    ax25_putchar(ctx, crch);
    10fc:	c8 01       	movw	r24, r16
    10fe:	0e 94 44 07 	call	0xe88	; 0xe88 <ax25_putchar>

    fputc(HDLC_FLAG, ctx->ch);
    1102:	f7 01       	movw	r30, r14
    1104:	60 81       	ld	r22, Z
    1106:	71 81       	ldd	r23, Z+1	; 0x01
    1108:	8e e7       	ldi	r24, 0x7E	; 126
    110a:	90 e0       	ldi	r25, 0x00	; 0
}
    110c:	df 91       	pop	r29
    110e:	cf 91       	pop	r28
    1110:	1f 91       	pop	r17
    1112:	0f 91       	pop	r16
    1114:	ff 90       	pop	r15
    1116:	ef 90       	pop	r14
    1118:	df 90       	pop	r13
    111a:	cf 90       	pop	r12
    111c:	bf 90       	pop	r11
    111e:	af 90       	pop	r10
    1120:	9f 90       	pop	r9
    1122:	8f 90       	pop	r8
    uint8_t crcl = (ctx->crc_out & 0xff) ^ 0xff;
    uint8_t crch = (ctx->crc_out >> 8) ^ 0xff;
    ax25_putchar(ctx, crcl);
    ax25_putchar(ctx, crch);

    fputc(HDLC_FLAG, ctx->ch);
    1124:	0c 94 1a 0c 	jmp	0x1834	; 0x1834 <fputc>

00001128 <kiss_init>:

unsigned long slotTime = 200;
uint8_t p = 63;

void kiss_init(AX25Ctx *ax25, Afsk *afsk, Serial *ser) {
    ax25ctx = ax25;
    1128:	90 93 64 08 	sts	0x0864, r25	; 0x800864 <ax25ctx+0x1>
    112c:	80 93 63 08 	sts	0x0863, r24	; 0x800863 <ax25ctx>
    serial = ser;
    1130:	50 93 2f 05 	sts	0x052F, r21	; 0x80052f <serial+0x1>
    1134:	40 93 2e 05 	sts	0x052E, r20	; 0x80052e <serial>
    channel = afsk;
    1138:	70 93 66 08 	sts	0x0866, r23	; 0x800866 <channel+0x1>
    113c:	60 93 65 08 	sts	0x0865, r22	; 0x800865 <channel>
    1140:	08 95       	ret

00001142 <kiss_messageCallback>:
}

void kiss_messageCallback(AX25Ctx *ctx) {
    1142:	ef 92       	push	r14
    1144:	ff 92       	push	r15
    1146:	0f 93       	push	r16
    1148:	1f 93       	push	r17
    114a:	cf 93       	push	r28
    114c:	df 93       	push	r29
    114e:	ec 01       	movw	r28, r24
    fputc(FEND, &serial->uart0);
    1150:	60 91 2e 05 	lds	r22, 0x052E	; 0x80052e <serial>
    1154:	70 91 2f 05 	lds	r23, 0x052F	; 0x80052f <serial+0x1>
    1158:	80 ec       	ldi	r24, 0xC0	; 192
    115a:	90 e0       	ldi	r25, 0x00	; 0
    115c:	0e 94 1a 0c 	call	0x1834	; 0x1834 <fputc>
    fputc(0x00, &serial->uart0);
    1160:	60 91 2e 05 	lds	r22, 0x052E	; 0x80052e <serial>
    1164:	70 91 2f 05 	lds	r23, 0x052F	; 0x80052f <serial+0x1>
    1168:	80 e0       	ldi	r24, 0x00	; 0
    116a:	90 e0       	ldi	r25, 0x00	; 0
    116c:	0e 94 1a 0c 	call	0x1834	; 0x1834 <fputc>
    for (unsigned i = 0; i < ctx->frame_len-2; i++) {
    1170:	8e 01       	movw	r16, r28
    1172:	7e 01       	movw	r14, r28
    1174:	86 ee       	ldi	r24, 0xE6	; 230
    1176:	e8 1a       	sub	r14, r24
    1178:	8c ef       	ldi	r24, 0xFC	; 252
    117a:	f8 0a       	sbc	r15, r24
    117c:	f7 01       	movw	r30, r14
    117e:	20 81       	ld	r18, Z
    1180:	31 81       	ldd	r19, Z+1	; 0x01
    1182:	22 50       	subi	r18, 0x02	; 2
    1184:	31 09       	sbc	r19, r1
    1186:	60 91 2e 05 	lds	r22, 0x052E	; 0x80052e <serial>
    118a:	70 91 2f 05 	lds	r23, 0x052F	; 0x80052f <serial+0x1>
    118e:	c8 01       	movw	r24, r16
    1190:	8c 1b       	sub	r24, r28
    1192:	9d 0b       	sbc	r25, r29
    1194:	82 17       	cp	r24, r18
    1196:	93 07       	cpc	r25, r19
    1198:	08 f5       	brcc	.+66     	; 0x11dc <kiss_messageCallback+0x9a>
        uint8_t b = ctx->buf[i];
    119a:	f8 01       	movw	r30, r16
    119c:	81 91       	ld	r24, Z+
    119e:	8f 01       	movw	r16, r30
        if (b == FEND) {
    11a0:	80 3c       	cpi	r24, 0xC0	; 192
    11a2:	59 f4       	brne	.+22     	; 0x11ba <kiss_messageCallback+0x78>
            fputc(FESC, &serial->uart0);
    11a4:	8b ed       	ldi	r24, 0xDB	; 219
    11a6:	90 e0       	ldi	r25, 0x00	; 0
    11a8:	0e 94 1a 0c 	call	0x1834	; 0x1834 <fputc>
            fputc(TFEND, &serial->uart0);
    11ac:	60 91 2e 05 	lds	r22, 0x052E	; 0x80052e <serial>
    11b0:	70 91 2f 05 	lds	r23, 0x052F	; 0x80052f <serial+0x1>
    11b4:	8c ed       	ldi	r24, 0xDC	; 220
    11b6:	90 e0       	ldi	r25, 0x00	; 0
    11b8:	0e c0       	rjmp	.+28     	; 0x11d6 <kiss_messageCallback+0x94>
        } else if (b == FESC) {
    11ba:	8b 3d       	cpi	r24, 0xDB	; 219
    11bc:	59 f4       	brne	.+22     	; 0x11d4 <kiss_messageCallback+0x92>
            fputc(FESC, &serial->uart0);
    11be:	8b ed       	ldi	r24, 0xDB	; 219
    11c0:	90 e0       	ldi	r25, 0x00	; 0
    11c2:	0e 94 1a 0c 	call	0x1834	; 0x1834 <fputc>
            fputc(TFESC, &serial->uart0);
    11c6:	60 91 2e 05 	lds	r22, 0x052E	; 0x80052e <serial>
    11ca:	70 91 2f 05 	lds	r23, 0x052F	; 0x80052f <serial+0x1>
    11ce:	8d ed       	ldi	r24, 0xDD	; 221
    11d0:	90 e0       	ldi	r25, 0x00	; 0
    11d2:	01 c0       	rjmp	.+2      	; 0x11d6 <kiss_messageCallback+0x94>
        } else {
            fputc(b, &serial->uart0);
    11d4:	90 e0       	ldi	r25, 0x00	; 0
    11d6:	0e 94 1a 0c 	call	0x1834	; 0x1834 <fputc>
    11da:	d0 cf       	rjmp	.-96     	; 0x117c <kiss_messageCallback+0x3a>
        }
    }
    fputc(FEND, &serial->uart0);
    11dc:	80 ec       	ldi	r24, 0xC0	; 192
    11de:	90 e0       	ldi	r25, 0x00	; 0
}
    11e0:	df 91       	pop	r29
    11e2:	cf 91       	pop	r28
    11e4:	1f 91       	pop	r17
    11e6:	0f 91       	pop	r16
    11e8:	ff 90       	pop	r15
    11ea:	ef 90       	pop	r14
            fputc(TFESC, &serial->uart0);
        } else {
            fputc(b, &serial->uart0);
        }
    }
    fputc(FEND, &serial->uart0);
    11ec:	0c 94 1a 0c 	jmp	0x1834	; 0x1834 <fputc>

000011f0 <kiss_csma>:
}

void kiss_csma(AX25Ctx *ctx, uint8_t *buf, size_t len) {
    11f0:	4f 92       	push	r4
    11f2:	5f 92       	push	r5
    11f4:	6f 92       	push	r6
    11f6:	7f 92       	push	r7
    11f8:	8f 92       	push	r8
    11fa:	9f 92       	push	r9
    11fc:	af 92       	push	r10
    11fe:	bf 92       	push	r11
    1200:	ef 92       	push	r14
    1202:	ff 92       	push	r15
    1204:	0f 93       	push	r16
    1206:	1f 93       	push	r17
    1208:	cf 93       	push	r28
    120a:	df 93       	push	r29
    120c:	ec 01       	movw	r28, r24
    120e:	8b 01       	movw	r16, r22
    1210:	7a 01       	movw	r14, r20
    bool sent = false;
    while (!sent) {
        //puts("Waiting in CSMA");
        if(!channel->hdlc.receiving) {
    1212:	e0 91 65 08 	lds	r30, 0x0865	; 0x800865 <channel>
    1216:	f0 91 66 08 	lds	r31, 0x0866	; 0x800866 <channel+0x1>
    121a:	81 89       	ldd	r24, Z+17	; 0x11
    121c:	81 11       	cpse	r24, r1
    121e:	45 c0       	rjmp	.+138    	; 0x12aa <kiss_csma+0xba>
            uint8_t tp = rand() & 0xFF;
    1220:	0e 94 cc 0b 	call	0x1798	; 0x1798 <rand>
            if (tp < p) {
    1224:	90 91 00 01 	lds	r25, 0x0100	; 0x800100 <__data_start>
    1228:	89 17       	cp	r24, r25
    122a:	98 f4       	brcc	.+38     	; 0x1252 <kiss_csma+0x62>
                ax25_sendRaw(ctx, buf, len);
    122c:	a7 01       	movw	r20, r14
    122e:	b8 01       	movw	r22, r16
    1230:	ce 01       	movw	r24, r28
            }
        }

    }
    
}
    1232:	df 91       	pop	r29
    1234:	cf 91       	pop	r28
    1236:	1f 91       	pop	r17
    1238:	0f 91       	pop	r16
    123a:	ff 90       	pop	r15
    123c:	ef 90       	pop	r14
    123e:	bf 90       	pop	r11
    1240:	af 90       	pop	r10
    1242:	9f 90       	pop	r9
    1244:	8f 90       	pop	r8
    1246:	7f 90       	pop	r7
    1248:	6f 90       	pop	r6
    124a:	5f 90       	pop	r5
    124c:	4f 90       	pop	r4
    while (!sent) {
        //puts("Waiting in CSMA");
        if(!channel->hdlc.receiving) {
            uint8_t tp = rand() & 0xFF;
            if (tp < p) {
                ax25_sendRaw(ctx, buf, len);
    124e:	0c 94 45 08 	jmp	0x108a	; 0x108a <ax25_sendRaw>
volatile ticks_t _clock;

static inline ticks_t timer_clock(void) {
    ticks_t result;

    ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
    1252:	8f b7       	in	r24, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    1254:	f8 94       	cli
        result = _clock;
    1256:	80 90 2a 05 	lds	r8, 0x052A	; 0x80052a <_clock>
    125a:	90 90 2b 05 	lds	r9, 0x052B	; 0x80052b <_clock+0x1>
    125e:	a0 90 2c 05 	lds	r10, 0x052C	; 0x80052c <_clock+0x2>
    1262:	b0 90 2d 05 	lds	r11, 0x052D	; 0x80052d <_clock+0x3>
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
    1266:	8f bf       	out	0x3f, r24	; 63
    return result;
}


inline ticks_t ms_to_ticks(mtime_t ms) {
    return ms * DIV_ROUND(CLOCK_TICKS_PER_SEC, 1000);
    1268:	20 91 01 01 	lds	r18, 0x0101	; 0x800101 <slotTime>
    126c:	30 91 02 01 	lds	r19, 0x0102	; 0x800102 <slotTime+0x1>
    1270:	40 91 03 01 	lds	r20, 0x0103	; 0x800103 <slotTime+0x2>
    1274:	50 91 04 01 	lds	r21, 0x0104	; 0x800104 <slotTime+0x3>
    1278:	aa e0       	ldi	r26, 0x0A	; 10
    127a:	b0 e0       	ldi	r27, 0x00	; 0
    127c:	0e 94 75 0b 	call	0x16ea	; 0x16ea <__muluhisi3>
volatile ticks_t _clock;

static inline ticks_t timer_clock(void) {
    ticks_t result;

    ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
    1280:	2f b7       	in	r18, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    1282:	f8 94       	cli
        result = _clock;
    1284:	40 90 2a 05 	lds	r4, 0x052A	; 0x80052a <_clock>
    1288:	50 90 2b 05 	lds	r5, 0x052B	; 0x80052b <_clock+0x1>
    128c:	60 90 2c 05 	lds	r6, 0x052C	; 0x80052c <_clock+0x2>
    1290:	70 90 2d 05 	lds	r7, 0x052D	; 0x80052d <_clock+0x3>
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
    1294:	2f bf       	out	0x3f, r18	; 63
                sent = true;
            } else {
                ticks_t start = timer_clock();
                long slot_ticks = ms_to_ticks(slotTime);
                while (timer_clock() - start < slot_ticks) {
    1296:	48 18       	sub	r4, r8
    1298:	59 08       	sbc	r5, r9
    129a:	6a 08       	sbc	r6, r10
    129c:	7b 08       	sbc	r7, r11
    129e:	46 16       	cp	r4, r22
    12a0:	57 06       	cpc	r5, r23
    12a2:	68 06       	cpc	r6, r24
    12a4:	79 06       	cpc	r7, r25
    12a6:	64 f3       	brlt	.-40     	; 0x1280 <kiss_csma+0x90>
    12a8:	b4 cf       	rjmp	.-152    	; 0x1212 <kiss_csma+0x22>
                    cpu_relax();
                }
            }
        } else {
            while (!sent && channel->hdlc.receiving) {
    12aa:	e0 91 65 08 	lds	r30, 0x0865	; 0x800865 <channel>
    12ae:	f0 91 66 08 	lds	r31, 0x0866	; 0x800866 <channel+0x1>
    12b2:	81 89       	ldd	r24, Z+17	; 0x11
    12b4:	88 23       	and	r24, r24
    12b6:	09 f4       	brne	.+2      	; 0x12ba <kiss_csma+0xca>
    12b8:	ac cf       	rjmp	.-168    	; 0x1212 <kiss_csma+0x22>
                // Continously poll the modem for data
                // while waiting, so we don't overrun
                // receive buffers
                ax25_poll(ax25ctx);
    12ba:	80 91 63 08 	lds	r24, 0x0863	; 0x800863 <ax25ctx>
    12be:	90 91 64 08 	lds	r25, 0x0864	; 0x800864 <ax25ctx+0x1>
    12c2:	0e 94 a0 07 	call	0xf40	; 0xf40 <ax25_poll>

                if (channel->status != 0) {
    12c6:	e0 91 65 08 	lds	r30, 0x0865	; 0x800865 <channel>
    12ca:	f0 91 66 08 	lds	r31, 0x0866	; 0x800866 <channel+0x1>
    12ce:	e8 53       	subi	r30, 0x38	; 56
    12d0:	ff 4f       	sbci	r31, 0xFF	; 255
    12d2:	80 81       	ld	r24, Z
    12d4:	91 81       	ldd	r25, Z+1	; 0x01
    12d6:	89 2b       	or	r24, r25
    12d8:	41 f3       	breq	.-48     	; 0x12aa <kiss_csma+0xba>
                    // If an overflow or other error
                    // occurs, we'll back off and drop
                    // this packet silently.
                    channel->status = 0;
    12da:	11 82       	std	Z+1, r1	; 0x01
    12dc:	10 82       	st	Z, r1
            }
        }

    }
    
}
    12de:	df 91       	pop	r29
    12e0:	cf 91       	pop	r28
    12e2:	1f 91       	pop	r17
    12e4:	0f 91       	pop	r16
    12e6:	ff 90       	pop	r15
    12e8:	ef 90       	pop	r14
    12ea:	bf 90       	pop	r11
    12ec:	af 90       	pop	r10
    12ee:	9f 90       	pop	r9
    12f0:	8f 90       	pop	r8
    12f2:	7f 90       	pop	r7
    12f4:	6f 90       	pop	r6
    12f6:	5f 90       	pop	r5
    12f8:	4f 90       	pop	r4
    12fa:	08 95       	ret

000012fc <kiss_serialCallback>:

void kiss_serialCallback(uint8_t sbyte) {
    if (IN_FRAME && sbyte == FEND && command == CMD_DATA) {
    12fc:	90 91 67 08 	lds	r25, 0x0867	; 0x800867 <IN_FRAME>
    1300:	99 23       	and	r25, r25
    1302:	a1 f0       	breq	.+40     	; 0x132c <kiss_serialCallback+0x30>
    1304:	80 3c       	cpi	r24, 0xC0	; 192
    1306:	01 f5       	brne	.+64     	; 0x1348 <kiss_serialCallback+0x4c>
    1308:	80 91 0d 01 	lds	r24, 0x010D	; 0x80010d <command>
    130c:	81 11       	cpse	r24, r1
    130e:	11 c0       	rjmp	.+34     	; 0x1332 <kiss_serialCallback+0x36>
        IN_FRAME = false;
    1310:	10 92 67 08 	sts	0x0867, r1	; 0x800867 <IN_FRAME>
        kiss_csma(ax25ctx, serialBuffer, frame_len);
    1314:	40 91 68 08 	lds	r20, 0x0868	; 0x800868 <frame_len>
    1318:	50 91 69 08 	lds	r21, 0x0869	; 0x800869 <frame_len+0x1>
    131c:	6a e1       	ldi	r22, 0x1A	; 26
    131e:	71 e0       	ldi	r23, 0x01	; 1
    1320:	80 91 63 08 	lds	r24, 0x0863	; 0x800863 <ax25ctx>
    1324:	90 91 64 08 	lds	r25, 0x0864	; 0x800864 <ax25ctx+0x1>
    1328:	0c 94 f8 08 	jmp	0x11f0	; 0x11f0 <kiss_csma>
    } else if (sbyte == FEND) {
    132c:	80 3c       	cpi	r24, 0xC0	; 192
    132e:	09 f0       	breq	.+2      	; 0x1332 <kiss_serialCallback+0x36>
    1330:	7b c0       	rjmp	.+246    	; 0x1428 <kiss_serialCallback+0x12c>
        IN_FRAME = true;
    1332:	81 e0       	ldi	r24, 0x01	; 1
    1334:	80 93 67 08 	sts	0x0867, r24	; 0x800867 <IN_FRAME>
        command = CMD_UNKNOWN;
    1338:	8e ef       	ldi	r24, 0xFE	; 254
    133a:	80 93 0d 01 	sts	0x010D, r24	; 0x80010d <command>
        frame_len = 0;
    133e:	10 92 69 08 	sts	0x0869, r1	; 0x800869 <frame_len+0x1>
    1342:	10 92 68 08 	sts	0x0868, r1	; 0x800868 <frame_len>
    1346:	08 95       	ret
    } else if (IN_FRAME && frame_len < AX25_MAX_FRAME_LEN) {
    1348:	20 91 68 08 	lds	r18, 0x0868	; 0x800868 <frame_len>
    134c:	30 91 69 08 	lds	r19, 0x0869	; 0x800869 <frame_len+0x1>
    1350:	28 31       	cpi	r18, 0x18	; 24
    1352:	93 e0       	ldi	r25, 0x03	; 3
    1354:	39 07       	cpc	r19, r25
    1356:	08 f0       	brcs	.+2      	; 0x135a <kiss_serialCallback+0x5e>
    1358:	67 c0       	rjmp	.+206    	; 0x1428 <kiss_serialCallback+0x12c>
    135a:	90 91 0d 01 	lds	r25, 0x010D	; 0x80010d <command>
        // Have a look at the command byte first
        if (frame_len == 0 && command == CMD_UNKNOWN) {
    135e:	21 15       	cp	r18, r1
    1360:	31 05       	cpc	r19, r1
    1362:	31 f4       	brne	.+12     	; 0x1370 <kiss_serialCallback+0x74>
    1364:	9e 3f       	cpi	r25, 0xFE	; 254
    1366:	21 f4       	brne	.+8      	; 0x1370 <kiss_serialCallback+0x74>
            // MicroModem supports only one HDLC port, so we
            // strip off the port nibble of the command byte
            sbyte = sbyte & 0x0F;
    1368:	8f 70       	andi	r24, 0x0F	; 15
            command = sbyte;
    136a:	80 93 0d 01 	sts	0x010D, r24	; 0x80010d <command>
    136e:	08 95       	ret
        } else if (command == CMD_DATA) {
    1370:	91 11       	cpse	r25, r1
    1372:	1f c0       	rjmp	.+62     	; 0x13b2 <kiss_serialCallback+0xb6>
            if (sbyte == FESC) {
    1374:	8b 3d       	cpi	r24, 0xDB	; 219
    1376:	21 f4       	brne	.+8      	; 0x1380 <kiss_serialCallback+0x84>
                ESCAPE = true;
    1378:	81 e0       	ldi	r24, 0x01	; 1
    137a:	80 93 62 08 	sts	0x0862, r24	; 0x800862 <ESCAPE>
    137e:	08 95       	ret
            } else {
                if (ESCAPE) {
    1380:	90 91 62 08 	lds	r25, 0x0862	; 0x800862 <ESCAPE>
    1384:	99 23       	and	r25, r25
    1386:	49 f0       	breq	.+18     	; 0x139a <kiss_serialCallback+0x9e>
                    if (sbyte == TFEND) sbyte = FEND;
    1388:	8c 3d       	cpi	r24, 0xDC	; 220
    138a:	21 f0       	breq	.+8      	; 0x1394 <kiss_serialCallback+0x98>
                    if (sbyte == TFESC) sbyte = FESC;
    138c:	8d 3d       	cpi	r24, 0xDD	; 221
    138e:	19 f4       	brne	.+6      	; 0x1396 <kiss_serialCallback+0x9a>
    1390:	8b ed       	ldi	r24, 0xDB	; 219
    1392:	01 c0       	rjmp	.+2      	; 0x1396 <kiss_serialCallback+0x9a>
        } else if (command == CMD_DATA) {
            if (sbyte == FESC) {
                ESCAPE = true;
            } else {
                if (ESCAPE) {
                    if (sbyte == TFEND) sbyte = FEND;
    1394:	80 ec       	ldi	r24, 0xC0	; 192
                    if (sbyte == TFESC) sbyte = FESC;
                    ESCAPE = false;
    1396:	10 92 62 08 	sts	0x0862, r1	; 0x800862 <ESCAPE>
                }
                serialBuffer[frame_len++] = sbyte;
    139a:	a9 01       	movw	r20, r18
    139c:	4f 5f       	subi	r20, 0xFF	; 255
    139e:	5f 4f       	sbci	r21, 0xFF	; 255
    13a0:	50 93 69 08 	sts	0x0869, r21	; 0x800869 <frame_len+0x1>
    13a4:	40 93 68 08 	sts	0x0868, r20	; 0x800868 <frame_len>
    13a8:	f9 01       	movw	r30, r18
    13aa:	e6 5e       	subi	r30, 0xE6	; 230
    13ac:	fe 4f       	sbci	r31, 0xFE	; 254
    13ae:	80 83       	st	Z, r24
    13b0:	08 95       	ret
            }
        } else if (command == CMD_TXDELAY) {
    13b2:	91 30       	cpi	r25, 0x01	; 1
    13b4:	79 f4       	brne	.+30     	; 0x13d4 <kiss_serialCallback+0xd8>
            custom_preamble = sbyte * 10UL;
    13b6:	28 2f       	mov	r18, r24
    13b8:	30 e0       	ldi	r19, 0x00	; 0
    13ba:	aa e0       	ldi	r26, 0x0A	; 10
    13bc:	b0 e0       	ldi	r27, 0x00	; 0
    13be:	0e 94 66 0b 	call	0x16cc	; 0x16cc <__umulhisi3>
    13c2:	60 93 09 01 	sts	0x0109, r22	; 0x800109 <custom_preamble>
    13c6:	70 93 0a 01 	sts	0x010A, r23	; 0x80010a <custom_preamble+0x1>
    13ca:	80 93 0b 01 	sts	0x010B, r24	; 0x80010b <custom_preamble+0x2>
    13ce:	90 93 0c 01 	sts	0x010C, r25	; 0x80010c <custom_preamble+0x3>
    13d2:	08 95       	ret
        } else if (command == CMD_TXTAIL) {
    13d4:	94 30       	cpi	r25, 0x04	; 4
    13d6:	89 f4       	brne	.+34     	; 0x13fa <kiss_serialCallback+0xfe>
            custom_tail = sbyte * 10;
    13d8:	2a e0       	ldi	r18, 0x0A	; 10
    13da:	82 9f       	mul	r24, r18
    13dc:	c0 01       	movw	r24, r0
    13de:	11 24       	eor	r1, r1
    13e0:	09 2e       	mov	r0, r25
    13e2:	00 0c       	add	r0, r0
    13e4:	aa 0b       	sbc	r26, r26
    13e6:	bb 0b       	sbc	r27, r27
    13e8:	80 93 05 01 	sts	0x0105, r24	; 0x800105 <custom_tail>
    13ec:	90 93 06 01 	sts	0x0106, r25	; 0x800106 <custom_tail+0x1>
    13f0:	a0 93 07 01 	sts	0x0107, r26	; 0x800107 <custom_tail+0x2>
    13f4:	b0 93 08 01 	sts	0x0108, r27	; 0x800108 <custom_tail+0x3>
    13f8:	08 95       	ret
        } else if (command == CMD_SLOTTIME) {
    13fa:	93 30       	cpi	r25, 0x03	; 3
    13fc:	89 f4       	brne	.+34     	; 0x1420 <kiss_serialCallback+0x124>
            slotTime = sbyte * 10;
    13fe:	2a e0       	ldi	r18, 0x0A	; 10
    1400:	82 9f       	mul	r24, r18
    1402:	c0 01       	movw	r24, r0
    1404:	11 24       	eor	r1, r1
    1406:	09 2e       	mov	r0, r25
    1408:	00 0c       	add	r0, r0
    140a:	aa 0b       	sbc	r26, r26
    140c:	bb 0b       	sbc	r27, r27
    140e:	80 93 01 01 	sts	0x0101, r24	; 0x800101 <slotTime>
    1412:	90 93 02 01 	sts	0x0102, r25	; 0x800102 <slotTime+0x1>
    1416:	a0 93 03 01 	sts	0x0103, r26	; 0x800103 <slotTime+0x2>
    141a:	b0 93 04 01 	sts	0x0104, r27	; 0x800104 <slotTime+0x3>
    141e:	08 95       	ret
        } else if (command == CMD_P) {
    1420:	92 30       	cpi	r25, 0x02	; 2
    1422:	11 f4       	brne	.+4      	; 0x1428 <kiss_serialCallback+0x12c>
            p = sbyte;
    1424:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
    1428:	08 95       	ret

0000142a <__vector_14>:
#define set_tx_pin_high()      ( SOFTUART_TXPORT |=  ( 1 << SOFTUART_TXBIT ) )
#define set_tx_pin_low()       ( SOFTUART_TXPORT &= ~( 1 << SOFTUART_TXBIT ) )
#define get_rx_pin_status()    ( SOFTUART_RXPIN  &   ( 1 << SOFTUART_RXBIT ) )

ISR(SOFTUART_T_COMP_LABEL)
{
    142a:	1f 92       	push	r1
    142c:	0f 92       	push	r0
    142e:	0f b6       	in	r0, 0x3f	; 63
    1430:	0f 92       	push	r0
    1432:	11 24       	eor	r1, r1
    1434:	8f 93       	push	r24
    1436:	9f 93       	push	r25
    1438:	ef 93       	push	r30
    143a:	ff 93       	push	r31
	
	unsigned char start_bit, flag_in;
	unsigned char tmp;
	
	// Transmitter Section
	if ( flag_tx_busy == SU_TRUE ) {
    143c:	80 91 3b 04 	lds	r24, 0x043B	; 0x80043b <flag_tx_busy>
    1440:	81 30       	cpi	r24, 0x01	; 1
    1442:	19 f5       	brne	.+70     	; 0x148a <__vector_14+0x60>
		tmp = timer_tx_ctr;
    1444:	80 91 3a 04 	lds	r24, 0x043A	; 0x80043a <timer_tx_ctr>
		if ( --tmp == 0 ) { // if ( --timer_tx_ctr <= 0 )
    1448:	81 50       	subi	r24, 0x01	; 1
    144a:	e9 f4       	brne	.+58     	; 0x1486 <__vector_14+0x5c>
			if ( internal_tx_buffer & 0x01 ) {
    144c:	80 91 37 04 	lds	r24, 0x0437	; 0x800437 <internal_tx_buffer>
    1450:	90 91 38 04 	lds	r25, 0x0438	; 0x800438 <internal_tx_buffer+0x1>
    1454:	80 ff       	sbrs	r24, 0
    1456:	02 c0       	rjmp	.+4      	; 0x145c <__vector_14+0x32>
				set_tx_pin_high();
    1458:	44 9a       	sbi	0x08, 4	; 8
    145a:	01 c0       	rjmp	.+2      	; 0x145e <__vector_14+0x34>
			}
			else {
				set_tx_pin_low();
    145c:	44 98       	cbi	0x08, 4	; 8
			}
			internal_tx_buffer >>= 1;
    145e:	80 91 37 04 	lds	r24, 0x0437	; 0x800437 <internal_tx_buffer>
    1462:	90 91 38 04 	lds	r25, 0x0438	; 0x800438 <internal_tx_buffer+0x1>
    1466:	96 95       	lsr	r25
    1468:	87 95       	ror	r24
    146a:	90 93 38 04 	sts	0x0438, r25	; 0x800438 <internal_tx_buffer+0x1>
    146e:	80 93 37 04 	sts	0x0437, r24	; 0x800437 <internal_tx_buffer>
			tmp = 3; // timer_tx_ctr = 3;
			if ( --bits_left_in_tx == 0 ) {
    1472:	80 91 39 04 	lds	r24, 0x0439	; 0x800439 <bits_left_in_tx>
    1476:	81 50       	subi	r24, 0x01	; 1
    1478:	80 93 39 04 	sts	0x0439, r24	; 0x800439 <bits_left_in_tx>
    147c:	81 11       	cpse	r24, r1
    147e:	02 c0       	rjmp	.+4      	; 0x1484 <__vector_14+0x5a>
				flag_tx_busy = SU_FALSE;
    1480:	10 92 3b 04 	sts	0x043B, r1	; 0x80043b <flag_tx_busy>
			}
			else {
				set_tx_pin_low();
			}
			internal_tx_buffer >>= 1;
			tmp = 3; // timer_tx_ctr = 3;
    1484:	83 e0       	ldi	r24, 0x03	; 3
			if ( --bits_left_in_tx == 0 ) {
				flag_tx_busy = SU_FALSE;
			}
		}
		timer_tx_ctr = tmp;
    1486:	80 93 3a 04 	sts	0x043A, r24	; 0x80043a <timer_tx_ctr>
	}

	// Receiver Section
	if ( flag_rx_off == SU_FALSE ) {
    148a:	80 91 3d 04 	lds	r24, 0x043D	; 0x80043d <flag_rx_off>
    148e:	81 11       	cpse	r24, r1
    1490:	52 c0       	rjmp	.+164    	; 0x1536 <__vector_14+0x10c>
		if ( flag_rx_waiting_for_stop_bit ) {
    1492:	80 91 36 04 	lds	r24, 0x0436	; 0x800436 <flag_rx_waiting_for_stop_bit.1675>
    1496:	88 23       	and	r24, r24
    1498:	e9 f0       	breq	.+58     	; 0x14d4 <__vector_14+0xaa>
			if ( --timer_rx_ctr == 0 ) {
    149a:	80 91 35 04 	lds	r24, 0x0435	; 0x800435 <timer_rx_ctr.1677>
    149e:	81 50       	subi	r24, 0x01	; 1
    14a0:	80 93 35 04 	sts	0x0435, r24	; 0x800435 <timer_rx_ctr.1677>
    14a4:	81 11       	cpse	r24, r1
    14a6:	47 c0       	rjmp	.+142    	; 0x1536 <__vector_14+0x10c>
				flag_rx_waiting_for_stop_bit = SU_FALSE;
    14a8:	10 92 36 04 	sts	0x0436, r1	; 0x800436 <flag_rx_waiting_for_stop_bit.1675>
				flag_rx_ready = SU_FALSE;
    14ac:	10 92 3c 04 	sts	0x043C, r1	; 0x80043c <flag_rx_ready>
				inbuf[qin] = internal_rx_buffer;
    14b0:	e0 91 3f 04 	lds	r30, 0x043F	; 0x80043f <qin>
    14b4:	f0 e0       	ldi	r31, 0x00	; 0
    14b6:	80 91 34 04 	lds	r24, 0x0434	; 0x800434 <internal_rx_buffer.1679>
    14ba:	e0 5c       	subi	r30, 0xC0	; 192
    14bc:	fb 4f       	sbci	r31, 0xFB	; 251
    14be:	80 83       	st	Z, r24
				if ( ++qin >= SOFTUART_IN_BUF_SIZE ) {
    14c0:	80 91 3f 04 	lds	r24, 0x043F	; 0x80043f <qin>
    14c4:	8f 5f       	subi	r24, 0xFF	; 255
    14c6:	80 93 3f 04 	sts	0x043F, r24	; 0x80043f <qin>
    14ca:	80 32       	cpi	r24, 0x20	; 32
    14cc:	a0 f1       	brcs	.+104    	; 0x1536 <__vector_14+0x10c>
					// overflow - reset inbuf-index
					qin = 0;
    14ce:	10 92 3f 04 	sts	0x043F, r1	; 0x80043f <qin>
    14d2:	31 c0       	rjmp	.+98     	; 0x1536 <__vector_14+0x10c>
				}
			}
		}
		else {  // rx_test_busy
			if ( flag_rx_ready == SU_FALSE ) {
    14d4:	80 91 3c 04 	lds	r24, 0x043C	; 0x80043c <flag_rx_ready>
    14d8:	81 11       	cpse	r24, r1
    14da:	10 c0       	rjmp	.+32     	; 0x14fc <__vector_14+0xd2>
				start_bit = get_rx_pin_status();
				// test for start bit
				if ( start_bit == 0 ) {
    14dc:	33 99       	sbic	0x06, 3	; 6
    14de:	2b c0       	rjmp	.+86     	; 0x1536 <__vector_14+0x10c>
					flag_rx_ready      = SU_TRUE;
    14e0:	81 e0       	ldi	r24, 0x01	; 1
    14e2:	80 93 3c 04 	sts	0x043C, r24	; 0x80043c <flag_rx_ready>
					internal_rx_buffer = 0;
    14e6:	10 92 34 04 	sts	0x0434, r1	; 0x800434 <internal_rx_buffer.1679>
					timer_rx_ctr       = 4;
    14ea:	94 e0       	ldi	r25, 0x04	; 4
    14ec:	90 93 35 04 	sts	0x0435, r25	; 0x800435 <timer_rx_ctr.1677>
					bits_left_in_rx    = RX_NUM_OF_BITS;
    14f0:	98 e0       	ldi	r25, 0x08	; 8
    14f2:	90 93 33 04 	sts	0x0433, r25	; 0x800433 <bits_left_in_rx.1678>
					rx_mask            = 1;
    14f6:	80 93 32 04 	sts	0x0432, r24	; 0x800432 <rx_mask.1676>
    14fa:	1d c0       	rjmp	.+58     	; 0x1536 <__vector_14+0x10c>
				}
			}
			else {  // rx_busy
				tmp = timer_rx_ctr;
    14fc:	80 91 35 04 	lds	r24, 0x0435	; 0x800435 <timer_rx_ctr.1677>
				if ( --tmp == 0 ) { // if ( --timer_rx_ctr == 0 ) {
    1500:	81 50       	subi	r24, 0x01	; 1
    1502:	b9 f4       	brne	.+46     	; 0x1532 <__vector_14+0x108>
    1504:	80 91 32 04 	lds	r24, 0x0432	; 0x800432 <rx_mask.1676>
					// rcv
					tmp = 3;
					flag_in = get_rx_pin_status();
					if ( flag_in ) {
    1508:	33 9b       	sbis	0x06, 3	; 6
    150a:	05 c0       	rjmp	.+10     	; 0x1516 <__vector_14+0xec>
						internal_rx_buffer |= rx_mask;
    150c:	90 91 34 04 	lds	r25, 0x0434	; 0x800434 <internal_rx_buffer.1679>
    1510:	98 2b       	or	r25, r24
    1512:	90 93 34 04 	sts	0x0434, r25	; 0x800434 <internal_rx_buffer.1679>
					}
					rx_mask <<= 1;
    1516:	88 0f       	add	r24, r24
    1518:	80 93 32 04 	sts	0x0432, r24	; 0x800432 <rx_mask.1676>
					if ( --bits_left_in_rx == 0 ) {
    151c:	80 91 33 04 	lds	r24, 0x0433	; 0x800433 <bits_left_in_rx.1678>
    1520:	81 50       	subi	r24, 0x01	; 1
    1522:	80 93 33 04 	sts	0x0433, r24	; 0x800433 <bits_left_in_rx.1678>
    1526:	81 11       	cpse	r24, r1
    1528:	03 c0       	rjmp	.+6      	; 0x1530 <__vector_14+0x106>
						flag_rx_waiting_for_stop_bit = SU_TRUE;
    152a:	81 e0       	ldi	r24, 0x01	; 1
    152c:	80 93 36 04 	sts	0x0436, r24	; 0x800436 <flag_rx_waiting_for_stop_bit.1675>
			}
			else {  // rx_busy
				tmp = timer_rx_ctr;
				if ( --tmp == 0 ) { // if ( --timer_rx_ctr == 0 ) {
					// rcv
					tmp = 3;
    1530:	83 e0       	ldi	r24, 0x03	; 3
					rx_mask <<= 1;
					if ( --bits_left_in_rx == 0 ) {
						flag_rx_waiting_for_stop_bit = SU_TRUE;
					}
				}
				timer_rx_ctr = tmp;
    1532:	80 93 35 04 	sts	0x0435, r24	; 0x800435 <timer_rx_ctr.1677>
			}
		}
	}
}
    1536:	ff 91       	pop	r31
    1538:	ef 91       	pop	r30
    153a:	9f 91       	pop	r25
    153c:	8f 91       	pop	r24
    153e:	0f 90       	pop	r0
    1540:	0f be       	out	0x3f, r0	; 63
    1542:	0f 90       	pop	r0
    1544:	1f 90       	pop	r1
    1546:	18 95       	reti

00001548 <softuart_init>:
	SREG = sreg_tmp;
}

void softuart_init( void )
{
	flag_tx_busy  = SU_FALSE;
    1548:	10 92 3b 04 	sts	0x043B, r1	; 0x80043b <flag_tx_busy>
	flag_rx_ready = SU_FALSE;
    154c:	10 92 3c 04 	sts	0x043C, r1	; 0x80043c <flag_rx_ready>
	flag_rx_off   = SU_FALSE;
    1550:	10 92 3d 04 	sts	0x043D, r1	; 0x80043d <flag_rx_off>
	
	set_tx_pin_high(); /* mt: set to high to avoid garbage on init */
    1554:	44 9a       	sbi	0x08, 4	; 8
}

static void io_init(void)
{
	// TX-Pin as output
	SOFTUART_TXDDR |=  ( 1 << SOFTUART_TXBIT );
    1556:	3c 9a       	sbi	0x07, 4	; 7
	// RX-Pin as input
	SOFTUART_RXDDR &= ~( 1 << SOFTUART_RXBIT );
    1558:	3b 98       	cbi	0x07, 3	; 7

static void timer_init(void)
{
	unsigned char sreg_tmp;
	
	sreg_tmp = SREG;
    155a:	9f b7       	in	r25, 0x3f	; 63
	cli();
    155c:	f8 94       	cli
	
	SOFTUART_T_COMP_REG = SOFTUART_TIMERTOP;     /* set top */
    155e:	81 e2       	ldi	r24, 0x21	; 33
    1560:	87 bd       	out	0x27, r24	; 39

	SOFTUART_T_CONTR_REGA = SOFTUART_CTC_MASKA | SOFTUART_PRESC_MASKA;
    1562:	82 e0       	ldi	r24, 0x02	; 2
    1564:	84 bd       	out	0x24, r24	; 36
	SOFTUART_T_CONTR_REGB = SOFTUART_CTC_MASKB | SOFTUART_PRESC_MASKB;
    1566:	85 bd       	out	0x25, r24	; 37

	SOFTUART_T_INTCTL_REG |= SOFTUART_CMPINT_EN_MASK;
    1568:	ee e6       	ldi	r30, 0x6E	; 110
    156a:	f0 e0       	ldi	r31, 0x00	; 0
    156c:	80 81       	ld	r24, Z
    156e:	82 60       	ori	r24, 0x02	; 2
    1570:	80 83       	st	Z, r24

	SOFTUART_T_CNT_REG = 0; /* reset counter */
    1572:	16 bc       	out	0x26, r1	; 38
	
	SREG = sreg_tmp;
    1574:	9f bf       	out	0x3f, r25	; 63
    1576:	08 95       	ret

00001578 <softuart_turn_rx_on>:
	// add watchdog-reset here if needed
}

void softuart_turn_rx_on( void )
{
	flag_rx_off = SU_FALSE;
    1578:	10 92 3d 04 	sts	0x043D, r1	; 0x80043d <flag_rx_off>
    157c:	08 95       	ret

0000157e <softuart_turn_rx_off>:
}

void softuart_turn_rx_off( void )
{
	flag_rx_off = SU_TRUE;
    157e:	81 e0       	ldi	r24, 0x01	; 1
    1580:	80 93 3d 04 	sts	0x043D, r24	; 0x80043d <flag_rx_off>
    1584:	08 95       	ret

00001586 <softuart_getchar>:

char softuart_getchar( void )
{
	char ch;

	while ( qout == qin ) {
    1586:	90 91 3e 04 	lds	r25, 0x043E	; 0x80043e <qout>
    158a:	80 91 3f 04 	lds	r24, 0x043F	; 0x80043f <qin>
    158e:	98 17       	cp	r25, r24
    1590:	e1 f3       	breq	.-8      	; 0x158a <softuart_getchar+0x4>
		idle();
	}
	ch = inbuf[qout];
    1592:	e9 2f       	mov	r30, r25
    1594:	f0 e0       	ldi	r31, 0x00	; 0
    1596:	e0 5c       	subi	r30, 0xC0	; 192
    1598:	fb 4f       	sbci	r31, 0xFB	; 251
    159a:	80 81       	ld	r24, Z
	if ( ++qout >= SOFTUART_IN_BUF_SIZE ) {
    159c:	9f 5f       	subi	r25, 0xFF	; 255
    159e:	90 32       	cpi	r25, 0x20	; 32
    15a0:	18 f4       	brcc	.+6      	; 0x15a8 <softuart_getchar+0x22>
    15a2:	90 93 3e 04 	sts	0x043E, r25	; 0x80043e <qout>
    15a6:	08 95       	ret
		qout = 0;
    15a8:	10 92 3e 04 	sts	0x043E, r1	; 0x80043e <qout>
	}
	
	return( ch );
}
    15ac:	08 95       	ret

000015ae <softuart_kbhit>:

unsigned char softuart_kbhit( void )
{
	return( qin != qout );
    15ae:	20 91 3f 04 	lds	r18, 0x043F	; 0x80043f <qin>
    15b2:	81 e0       	ldi	r24, 0x01	; 1
    15b4:	90 91 3e 04 	lds	r25, 0x043E	; 0x80043e <qout>
    15b8:	29 13       	cpse	r18, r25
    15ba:	01 c0       	rjmp	.+2      	; 0x15be <softuart_kbhit+0x10>
    15bc:	80 e0       	ldi	r24, 0x00	; 0
}
    15be:	08 95       	ret

000015c0 <softuart_flush_input_buffer>:

void softuart_flush_input_buffer( void )
{
	qin  = 0;
    15c0:	10 92 3f 04 	sts	0x043F, r1	; 0x80043f <qin>
	qout = 0;
    15c4:	10 92 3e 04 	sts	0x043E, r1	; 0x80043e <qout>
    15c8:	08 95       	ret

000015ca <softuart_transmit_busy>:
}
	
unsigned char softuart_transmit_busy( void ) 
{
	return ( flag_tx_busy == SU_TRUE ) ? 1 : 0;
    15ca:	90 91 3b 04 	lds	r25, 0x043B	; 0x80043b <flag_tx_busy>
    15ce:	81 e0       	ldi	r24, 0x01	; 1
    15d0:	91 30       	cpi	r25, 0x01	; 1
    15d2:	09 f0       	breq	.+2      	; 0x15d6 <softuart_transmit_busy+0xc>
    15d4:	80 e0       	ldi	r24, 0x00	; 0
}
    15d6:	08 95       	ret

000015d8 <softuart_putchar>:

void softuart_putchar( const char ch )
{
	while ( flag_tx_busy == SU_TRUE ) {
    15d8:	90 91 3b 04 	lds	r25, 0x043B	; 0x80043b <flag_tx_busy>
    15dc:	91 30       	cpi	r25, 0x01	; 1
    15de:	e1 f3       	breq	.-8      	; 0x15d8 <softuart_putchar>
		; // wait for transmitter ready
		  // add watchdog-reset here if needed;
	}

	// invoke_UART_transmit
	timer_tx_ctr       = 3;
    15e0:	93 e0       	ldi	r25, 0x03	; 3
    15e2:	90 93 3a 04 	sts	0x043A, r25	; 0x80043a <timer_tx_ctr>
	bits_left_in_tx    = TX_NUM_OF_BITS;
    15e6:	9a e0       	ldi	r25, 0x0A	; 10
    15e8:	90 93 39 04 	sts	0x0439, r25	; 0x800439 <bits_left_in_tx>
	internal_tx_buffer = ( ch << 1 ) | 0x200;
    15ec:	90 e0       	ldi	r25, 0x00	; 0
    15ee:	88 0f       	add	r24, r24
    15f0:	99 1f       	adc	r25, r25
    15f2:	92 60       	ori	r25, 0x02	; 2
    15f4:	90 93 38 04 	sts	0x0438, r25	; 0x800438 <internal_tx_buffer+0x1>
    15f8:	80 93 37 04 	sts	0x0437, r24	; 0x800437 <internal_tx_buffer>
	flag_tx_busy       = SU_TRUE;
    15fc:	81 e0       	ldi	r24, 0x01	; 1
    15fe:	80 93 3b 04 	sts	0x043B, r24	; 0x80043b <flag_tx_busy>
    1602:	08 95       	ret

00001604 <softuart_puts>:
}
	
void softuart_puts( const char *s )
{
    1604:	cf 93       	push	r28
    1606:	df 93       	push	r29
    1608:	ec 01       	movw	r28, r24
	while ( *s ) {
    160a:	89 91       	ld	r24, Y+
    160c:	88 23       	and	r24, r24
    160e:	19 f0       	breq	.+6      	; 0x1616 <softuart_puts+0x12>
		softuart_putchar( *s++ );
    1610:	0e 94 ec 0a 	call	0x15d8	; 0x15d8 <softuart_putchar>
    1614:	fa cf       	rjmp	.-12     	; 0x160a <softuart_puts+0x6>
	}
}
    1616:	df 91       	pop	r29
    1618:	cf 91       	pop	r28
    161a:	08 95       	ret

0000161c <softuart_puts_p>:
    161c:	cf 93       	push	r28
    161e:	df 93       	push	r29
    1620:	fc 01       	movw	r30, r24
    1622:	84 91       	lpm	r24, Z
    1624:	ef 01       	movw	r28, r30
    1626:	21 96       	adiw	r28, 0x01	; 1
    1628:	88 23       	and	r24, r24
    162a:	21 f0       	breq	.+8      	; 0x1634 <softuart_puts_p+0x18>
    162c:	0e 94 ec 0a 	call	0x15d8	; 0x15d8 <softuart_putchar>
    1630:	fe 01       	movw	r30, r28
    1632:	f7 cf       	rjmp	.-18     	; 0x1622 <softuart_puts_p+0x6>
    1634:	df 91       	pop	r29
    1636:	cf 91       	pop	r28
    1638:	08 95       	ret

0000163a <main>:
#define CNTHALLO (unsigned int)(0xFFFF)
#else 
#define CNTHALLO (unsigned int)(0xFFFF/3)
#endif

	softuart_init();
    163a:	0e 94 a4 0a 	call	0x1548	; 0x1548 <softuart_init>
	softuart_turn_rx_on(); /* redundant - on by default */
    163e:	0e 94 bc 0a 	call	0x1578	; 0x1578 <softuart_turn_rx_on>
	
	sei();
    1642:	78 94       	sei

	softuart_puts_P( "\r\nSoftuart Demo-Application\r\n" );    // "implicit" PSTR
    1644:	8f ec       	ldi	r24, 0xCF	; 207
    1646:	90 e0       	ldi	r25, 0x00	; 0
    1648:	0e 94 0e 0b 	call	0x161c	; 0x161c <softuart_puts_p>
	softuart_puts_p( PSTR("generic softuart driver code by Colin Gittins\r\n") ); // explicit PSTR
    164c:	8f e9       	ldi	r24, 0x9F	; 159
    164e:	90 e0       	ldi	r25, 0x00	; 0
    1650:	0e 94 0e 0b 	call	0x161c	; 0x161c <softuart_puts_p>
	softuart_puts_p( pstring ); // pstring defined with PROGMEM
    1654:	88 e6       	ldi	r24, 0x68	; 104
    1656:	90 e0       	ldi	r25, 0x00	; 0
    1658:	0e 94 0e 0b 	call	0x161c	; 0x161c <softuart_puts_p>
	softuart_puts( "--\r\n" );  // string "from RAM"
    165c:	82 e1       	ldi	r24, 0x12	; 18
    165e:	91 e0       	ldi	r25, 0x01	; 1
    1660:	0e 94 02 0b 	call	0x1604	; 0x1604 <softuart_puts>


    init();
    1664:	0e 94 d8 01 	call	0x3b0	; 0x3b0 <init>
	DDRC |= _BV(1);
    1668:	39 9a       	sbi	0x07, 1	; 7
	PORTC |= _BV(1);
    166a:	41 9a       	sbi	0x08, 1	; 8

    #if SERIAL_PROTOCOL == PROTOCOL_KISS
        while (true) {
            ax25_poll(&AX25);
    166c:	8c e3       	ldi	r24, 0x3C	; 60
    166e:	95 e0       	ldi	r25, 0x05	; 5
    1670:	0e 94 a0 07 	call	0xf40	; 0xf40 <ax25_poll>
            
            if (serial_available(0)) {
    1674:	80 e0       	ldi	r24, 0x00	; 0
    1676:	0e 94 47 02 	call	0x48e	; 0x48e <serial_available>
    167a:	88 23       	and	r24, r24
    167c:	b9 f3       	breq	.-18     	; 0x166c <main+0x32>
                char sbyte = uart0_getchar_nowait();
    167e:	0e 94 51 02 	call	0x4a2	; 0x4a2 <uart0_getchar_nowait>
                kiss_serialCallback(sbyte);
    1682:	0e 94 7e 09 	call	0x12fc	; 0x12fc <kiss_serialCallback>
    1686:	f2 cf       	rjmp	.-28     	; 0x166c <main+0x32>

00001688 <__udivmodsi4>:
    1688:	a1 e2       	ldi	r26, 0x21	; 33
    168a:	1a 2e       	mov	r1, r26
    168c:	aa 1b       	sub	r26, r26
    168e:	bb 1b       	sub	r27, r27
    1690:	fd 01       	movw	r30, r26
    1692:	0d c0       	rjmp	.+26     	; 0x16ae <__udivmodsi4_ep>

00001694 <__udivmodsi4_loop>:
    1694:	aa 1f       	adc	r26, r26
    1696:	bb 1f       	adc	r27, r27
    1698:	ee 1f       	adc	r30, r30
    169a:	ff 1f       	adc	r31, r31
    169c:	a2 17       	cp	r26, r18
    169e:	b3 07       	cpc	r27, r19
    16a0:	e4 07       	cpc	r30, r20
    16a2:	f5 07       	cpc	r31, r21
    16a4:	20 f0       	brcs	.+8      	; 0x16ae <__udivmodsi4_ep>
    16a6:	a2 1b       	sub	r26, r18
    16a8:	b3 0b       	sbc	r27, r19
    16aa:	e4 0b       	sbc	r30, r20
    16ac:	f5 0b       	sbc	r31, r21

000016ae <__udivmodsi4_ep>:
    16ae:	66 1f       	adc	r22, r22
    16b0:	77 1f       	adc	r23, r23
    16b2:	88 1f       	adc	r24, r24
    16b4:	99 1f       	adc	r25, r25
    16b6:	1a 94       	dec	r1
    16b8:	69 f7       	brne	.-38     	; 0x1694 <__udivmodsi4_loop>
    16ba:	60 95       	com	r22
    16bc:	70 95       	com	r23
    16be:	80 95       	com	r24
    16c0:	90 95       	com	r25
    16c2:	9b 01       	movw	r18, r22
    16c4:	ac 01       	movw	r20, r24
    16c6:	bd 01       	movw	r22, r26
    16c8:	cf 01       	movw	r24, r30
    16ca:	08 95       	ret

000016cc <__umulhisi3>:
    16cc:	a2 9f       	mul	r26, r18
    16ce:	b0 01       	movw	r22, r0
    16d0:	b3 9f       	mul	r27, r19
    16d2:	c0 01       	movw	r24, r0
    16d4:	a3 9f       	mul	r26, r19
    16d6:	70 0d       	add	r23, r0
    16d8:	81 1d       	adc	r24, r1
    16da:	11 24       	eor	r1, r1
    16dc:	91 1d       	adc	r25, r1
    16de:	b2 9f       	mul	r27, r18
    16e0:	70 0d       	add	r23, r0
    16e2:	81 1d       	adc	r24, r1
    16e4:	11 24       	eor	r1, r1
    16e6:	91 1d       	adc	r25, r1
    16e8:	08 95       	ret

000016ea <__muluhisi3>:
    16ea:	0e 94 66 0b 	call	0x16cc	; 0x16cc <__umulhisi3>
    16ee:	a5 9f       	mul	r26, r21
    16f0:	90 0d       	add	r25, r0
    16f2:	b4 9f       	mul	r27, r20
    16f4:	90 0d       	add	r25, r0
    16f6:	a4 9f       	mul	r26, r20
    16f8:	80 0d       	add	r24, r0
    16fa:	91 1d       	adc	r25, r1
    16fc:	11 24       	eor	r1, r1
    16fe:	08 95       	ret

00001700 <do_rand>:
    1700:	8f 92       	push	r8
    1702:	9f 92       	push	r9
    1704:	af 92       	push	r10
    1706:	bf 92       	push	r11
    1708:	cf 92       	push	r12
    170a:	df 92       	push	r13
    170c:	ef 92       	push	r14
    170e:	ff 92       	push	r15
    1710:	cf 93       	push	r28
    1712:	df 93       	push	r29
    1714:	ec 01       	movw	r28, r24
    1716:	68 81       	ld	r22, Y
    1718:	79 81       	ldd	r23, Y+1	; 0x01
    171a:	8a 81       	ldd	r24, Y+2	; 0x02
    171c:	9b 81       	ldd	r25, Y+3	; 0x03
    171e:	61 15       	cp	r22, r1
    1720:	71 05       	cpc	r23, r1
    1722:	81 05       	cpc	r24, r1
    1724:	91 05       	cpc	r25, r1
    1726:	21 f4       	brne	.+8      	; 0x1730 <do_rand+0x30>
    1728:	64 e2       	ldi	r22, 0x24	; 36
    172a:	79 ed       	ldi	r23, 0xD9	; 217
    172c:	8b e5       	ldi	r24, 0x5B	; 91
    172e:	97 e0       	ldi	r25, 0x07	; 7
    1730:	2d e1       	ldi	r18, 0x1D	; 29
    1732:	33 ef       	ldi	r19, 0xF3	; 243
    1734:	41 e0       	ldi	r20, 0x01	; 1
    1736:	50 e0       	ldi	r21, 0x00	; 0
    1738:	0e 94 52 0c 	call	0x18a4	; 0x18a4 <__divmodsi4>
    173c:	49 01       	movw	r8, r18
    173e:	5a 01       	movw	r10, r20
    1740:	9b 01       	movw	r18, r22
    1742:	ac 01       	movw	r20, r24
    1744:	a7 ea       	ldi	r26, 0xA7	; 167
    1746:	b1 e4       	ldi	r27, 0x41	; 65
    1748:	0e 94 75 0b 	call	0x16ea	; 0x16ea <__muluhisi3>
    174c:	6b 01       	movw	r12, r22
    174e:	7c 01       	movw	r14, r24
    1750:	ac ee       	ldi	r26, 0xEC	; 236
    1752:	b4 ef       	ldi	r27, 0xF4	; 244
    1754:	a5 01       	movw	r20, r10
    1756:	94 01       	movw	r18, r8
    1758:	0e 94 74 0c 	call	0x18e8	; 0x18e8 <__mulohisi3>
    175c:	dc 01       	movw	r26, r24
    175e:	cb 01       	movw	r24, r22
    1760:	8c 0d       	add	r24, r12
    1762:	9d 1d       	adc	r25, r13
    1764:	ae 1d       	adc	r26, r14
    1766:	bf 1d       	adc	r27, r15
    1768:	b7 ff       	sbrs	r27, 7
    176a:	03 c0       	rjmp	.+6      	; 0x1772 <do_rand+0x72>
    176c:	01 97       	sbiw	r24, 0x01	; 1
    176e:	a1 09       	sbc	r26, r1
    1770:	b0 48       	sbci	r27, 0x80	; 128
    1772:	88 83       	st	Y, r24
    1774:	99 83       	std	Y+1, r25	; 0x01
    1776:	aa 83       	std	Y+2, r26	; 0x02
    1778:	bb 83       	std	Y+3, r27	; 0x03
    177a:	9f 77       	andi	r25, 0x7F	; 127
    177c:	df 91       	pop	r29
    177e:	cf 91       	pop	r28
    1780:	ff 90       	pop	r15
    1782:	ef 90       	pop	r14
    1784:	df 90       	pop	r13
    1786:	cf 90       	pop	r12
    1788:	bf 90       	pop	r11
    178a:	af 90       	pop	r10
    178c:	9f 90       	pop	r9
    178e:	8f 90       	pop	r8
    1790:	08 95       	ret

00001792 <rand_r>:
    1792:	0e 94 80 0b 	call	0x1700	; 0x1700 <do_rand>
    1796:	08 95       	ret

00001798 <rand>:
    1798:	8e e0       	ldi	r24, 0x0E	; 14
    179a:	91 e0       	ldi	r25, 0x01	; 1
    179c:	0e 94 80 0b 	call	0x1700	; 0x1700 <do_rand>
    17a0:	08 95       	ret

000017a2 <srand>:
    17a2:	a0 e0       	ldi	r26, 0x00	; 0
    17a4:	b0 e0       	ldi	r27, 0x00	; 0
    17a6:	80 93 0e 01 	sts	0x010E, r24	; 0x80010e <next>
    17aa:	90 93 0f 01 	sts	0x010F, r25	; 0x80010f <next+0x1>
    17ae:	a0 93 10 01 	sts	0x0110, r26	; 0x800110 <next+0x2>
    17b2:	b0 93 11 01 	sts	0x0111, r27	; 0x800111 <next+0x3>
    17b6:	08 95       	ret

000017b8 <fgetc>:
    17b8:	cf 93       	push	r28
    17ba:	df 93       	push	r29
    17bc:	ec 01       	movw	r28, r24
    17be:	2b 81       	ldd	r18, Y+3	; 0x03
    17c0:	20 ff       	sbrs	r18, 0
    17c2:	33 c0       	rjmp	.+102    	; 0x182a <fgetc+0x72>
    17c4:	26 ff       	sbrs	r18, 6
    17c6:	0a c0       	rjmp	.+20     	; 0x17dc <fgetc+0x24>
    17c8:	2f 7b       	andi	r18, 0xBF	; 191
    17ca:	2b 83       	std	Y+3, r18	; 0x03
    17cc:	8e 81       	ldd	r24, Y+6	; 0x06
    17ce:	9f 81       	ldd	r25, Y+7	; 0x07
    17d0:	01 96       	adiw	r24, 0x01	; 1
    17d2:	9f 83       	std	Y+7, r25	; 0x07
    17d4:	8e 83       	std	Y+6, r24	; 0x06
    17d6:	8a 81       	ldd	r24, Y+2	; 0x02
    17d8:	90 e0       	ldi	r25, 0x00	; 0
    17da:	29 c0       	rjmp	.+82     	; 0x182e <fgetc+0x76>
    17dc:	22 ff       	sbrs	r18, 2
    17de:	0f c0       	rjmp	.+30     	; 0x17fe <fgetc+0x46>
    17e0:	e8 81       	ld	r30, Y
    17e2:	f9 81       	ldd	r31, Y+1	; 0x01
    17e4:	80 81       	ld	r24, Z
    17e6:	08 2e       	mov	r0, r24
    17e8:	00 0c       	add	r0, r0
    17ea:	99 0b       	sbc	r25, r25
    17ec:	00 97       	sbiw	r24, 0x00	; 0
    17ee:	19 f4       	brne	.+6      	; 0x17f6 <fgetc+0x3e>
    17f0:	20 62       	ori	r18, 0x20	; 32
    17f2:	2b 83       	std	Y+3, r18	; 0x03
    17f4:	1a c0       	rjmp	.+52     	; 0x182a <fgetc+0x72>
    17f6:	31 96       	adiw	r30, 0x01	; 1
    17f8:	f9 83       	std	Y+1, r31	; 0x01
    17fa:	e8 83       	st	Y, r30
    17fc:	0e c0       	rjmp	.+28     	; 0x181a <fgetc+0x62>
    17fe:	ea 85       	ldd	r30, Y+10	; 0x0a
    1800:	fb 85       	ldd	r31, Y+11	; 0x0b
    1802:	09 95       	icall
    1804:	97 ff       	sbrs	r25, 7
    1806:	09 c0       	rjmp	.+18     	; 0x181a <fgetc+0x62>
    1808:	2b 81       	ldd	r18, Y+3	; 0x03
    180a:	01 96       	adiw	r24, 0x01	; 1
    180c:	11 f0       	breq	.+4      	; 0x1812 <fgetc+0x5a>
    180e:	80 e2       	ldi	r24, 0x20	; 32
    1810:	01 c0       	rjmp	.+2      	; 0x1814 <fgetc+0x5c>
    1812:	80 e1       	ldi	r24, 0x10	; 16
    1814:	82 2b       	or	r24, r18
    1816:	8b 83       	std	Y+3, r24	; 0x03
    1818:	08 c0       	rjmp	.+16     	; 0x182a <fgetc+0x72>
    181a:	2e 81       	ldd	r18, Y+6	; 0x06
    181c:	3f 81       	ldd	r19, Y+7	; 0x07
    181e:	2f 5f       	subi	r18, 0xFF	; 255
    1820:	3f 4f       	sbci	r19, 0xFF	; 255
    1822:	3f 83       	std	Y+7, r19	; 0x07
    1824:	2e 83       	std	Y+6, r18	; 0x06
    1826:	99 27       	eor	r25, r25
    1828:	02 c0       	rjmp	.+4      	; 0x182e <fgetc+0x76>
    182a:	8f ef       	ldi	r24, 0xFF	; 255
    182c:	9f ef       	ldi	r25, 0xFF	; 255
    182e:	df 91       	pop	r29
    1830:	cf 91       	pop	r28
    1832:	08 95       	ret

00001834 <fputc>:
    1834:	0f 93       	push	r16
    1836:	1f 93       	push	r17
    1838:	cf 93       	push	r28
    183a:	df 93       	push	r29
    183c:	fb 01       	movw	r30, r22
    183e:	23 81       	ldd	r18, Z+3	; 0x03
    1840:	21 fd       	sbrc	r18, 1
    1842:	03 c0       	rjmp	.+6      	; 0x184a <fputc+0x16>
    1844:	8f ef       	ldi	r24, 0xFF	; 255
    1846:	9f ef       	ldi	r25, 0xFF	; 255
    1848:	28 c0       	rjmp	.+80     	; 0x189a <fputc+0x66>
    184a:	22 ff       	sbrs	r18, 2
    184c:	16 c0       	rjmp	.+44     	; 0x187a <fputc+0x46>
    184e:	46 81       	ldd	r20, Z+6	; 0x06
    1850:	57 81       	ldd	r21, Z+7	; 0x07
    1852:	24 81       	ldd	r18, Z+4	; 0x04
    1854:	35 81       	ldd	r19, Z+5	; 0x05
    1856:	42 17       	cp	r20, r18
    1858:	53 07       	cpc	r21, r19
    185a:	44 f4       	brge	.+16     	; 0x186c <fputc+0x38>
    185c:	a0 81       	ld	r26, Z
    185e:	b1 81       	ldd	r27, Z+1	; 0x01
    1860:	9d 01       	movw	r18, r26
    1862:	2f 5f       	subi	r18, 0xFF	; 255
    1864:	3f 4f       	sbci	r19, 0xFF	; 255
    1866:	31 83       	std	Z+1, r19	; 0x01
    1868:	20 83       	st	Z, r18
    186a:	8c 93       	st	X, r24
    186c:	26 81       	ldd	r18, Z+6	; 0x06
    186e:	37 81       	ldd	r19, Z+7	; 0x07
    1870:	2f 5f       	subi	r18, 0xFF	; 255
    1872:	3f 4f       	sbci	r19, 0xFF	; 255
    1874:	37 83       	std	Z+7, r19	; 0x07
    1876:	26 83       	std	Z+6, r18	; 0x06
    1878:	10 c0       	rjmp	.+32     	; 0x189a <fputc+0x66>
    187a:	eb 01       	movw	r28, r22
    187c:	09 2f       	mov	r16, r25
    187e:	18 2f       	mov	r17, r24
    1880:	00 84       	ldd	r0, Z+8	; 0x08
    1882:	f1 85       	ldd	r31, Z+9	; 0x09
    1884:	e0 2d       	mov	r30, r0
    1886:	09 95       	icall
    1888:	89 2b       	or	r24, r25
    188a:	e1 f6       	brne	.-72     	; 0x1844 <fputc+0x10>
    188c:	8e 81       	ldd	r24, Y+6	; 0x06
    188e:	9f 81       	ldd	r25, Y+7	; 0x07
    1890:	01 96       	adiw	r24, 0x01	; 1
    1892:	9f 83       	std	Y+7, r25	; 0x07
    1894:	8e 83       	std	Y+6, r24	; 0x06
    1896:	81 2f       	mov	r24, r17
    1898:	90 2f       	mov	r25, r16
    189a:	df 91       	pop	r29
    189c:	cf 91       	pop	r28
    189e:	1f 91       	pop	r17
    18a0:	0f 91       	pop	r16
    18a2:	08 95       	ret

000018a4 <__divmodsi4>:
    18a4:	05 2e       	mov	r0, r21
    18a6:	97 fb       	bst	r25, 7
    18a8:	1e f4       	brtc	.+6      	; 0x18b0 <__divmodsi4+0xc>
    18aa:	00 94       	com	r0
    18ac:	0e 94 69 0c 	call	0x18d2	; 0x18d2 <__negsi2>
    18b0:	57 fd       	sbrc	r21, 7
    18b2:	07 d0       	rcall	.+14     	; 0x18c2 <__divmodsi4_neg2>
    18b4:	0e 94 44 0b 	call	0x1688	; 0x1688 <__udivmodsi4>
    18b8:	07 fc       	sbrc	r0, 7
    18ba:	03 d0       	rcall	.+6      	; 0x18c2 <__divmodsi4_neg2>
    18bc:	4e f4       	brtc	.+18     	; 0x18d0 <__divmodsi4_exit>
    18be:	0c 94 69 0c 	jmp	0x18d2	; 0x18d2 <__negsi2>

000018c2 <__divmodsi4_neg2>:
    18c2:	50 95       	com	r21
    18c4:	40 95       	com	r20
    18c6:	30 95       	com	r19
    18c8:	21 95       	neg	r18
    18ca:	3f 4f       	sbci	r19, 0xFF	; 255
    18cc:	4f 4f       	sbci	r20, 0xFF	; 255
    18ce:	5f 4f       	sbci	r21, 0xFF	; 255

000018d0 <__divmodsi4_exit>:
    18d0:	08 95       	ret

000018d2 <__negsi2>:
    18d2:	90 95       	com	r25
    18d4:	80 95       	com	r24
    18d6:	70 95       	com	r23
    18d8:	61 95       	neg	r22
    18da:	7f 4f       	sbci	r23, 0xFF	; 255
    18dc:	8f 4f       	sbci	r24, 0xFF	; 255
    18de:	9f 4f       	sbci	r25, 0xFF	; 255
    18e0:	08 95       	ret

000018e2 <__mulshisi3>:
    18e2:	b7 ff       	sbrs	r27, 7
    18e4:	0c 94 75 0b 	jmp	0x16ea	; 0x16ea <__muluhisi3>

000018e8 <__mulohisi3>:
    18e8:	0e 94 75 0b 	call	0x16ea	; 0x16ea <__muluhisi3>
    18ec:	82 1b       	sub	r24, r18
    18ee:	93 0b       	sbc	r25, r19
    18f0:	08 95       	ret

000018f2 <_exit>:
    18f2:	f8 94       	cli

000018f4 <__stop_program>:
    18f4:	ff cf       	rjmp	.-2      	; 0x18f4 <__stop_program>
